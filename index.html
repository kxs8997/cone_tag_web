<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport meta tag for responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Autocross Mapper</title>
    <style>
        /* Basic Reset & Box Sizing */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Ensure HTML and Body take full space */
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent extra scrollbars on body */
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }

        /* Prevent text selection on UI elements */
        .noselect {
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Old versions of Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
        }

        /* Screen Management */
        .screen {
            display: none; /* Hidden by default */
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent content spillover */
            flex-direction: column; /* Most screens use flex column */
        }

        .screen.active {
            display: flex; /* Show active screen */
        }

        /* Main App Container (used within screens) */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%; /* Fill parent screen */
            width: 100%;
        }

        /* Header Styles */
        #header {
            padding: 8px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
            gap: 10px;
        }

        #location-info {
            background-color: rgba(40, 40, 40, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            flex-grow: 1; /* Allow info to take space */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-pill {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            margin-left: 5px;
            font-size: 11px;
            font-weight: bold;
        }

        .status-good { background-color: #34a853; color: white; }
        .status-bad { background-color: #ea4335; color: white; }
        .status-wait { background-color: #fbbc05; color: black; }

        /* Map Container & Canvas */
        #map-container, #chart-map-container {
            position: relative;
            flex-grow: 1; /* Take remaining vertical space */
            background-color: #111;
            overflow: hidden; /* Clip canvas content */
        }

        #canvas, #chart-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* Width/height set by JS */
            display: block; /* Prevent potential inline spacing issues */
        }

        /* Current Location Marker (Blue Dot) */
        #current-location {
            background-color: blue;
            border: 1px solid white;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5; /* Above canvas, below UI elements */
            display: none; /* Initially hidden until location is known */
        }

         /* Selected Cone Indicator */
        .selected-cone-indicator {
            position: absolute; /* Position relative to map container */
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            background-color: #FBBC05;
            color: black;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
            display: none; /* Hidden by default */
            z-index: 10;
        }

        /* Controls Area */
        #controls {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Space between control items */
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        /* Button Styles */
        button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            flex-grow: 1; /* Make buttons in a row share space */
            flex-basis: 0; /* Allow shrinking/growing equally */
            white-space: nowrap; /* Prevent text wrapping */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        button.primary { background-color: #4285f4; color: white; }
        button.active { background-color: #34a853; color: white; } /* Active selection state */
        button.danger { background-color: #ea4335; color: white; }
        button.warning { background-color: #fbbc05; color: black; }
        button:disabled { background-color: #777; color: #ccc; cursor: not-allowed; }

        /* Slider Styles */
        .slider-container {
            display: flex;
            flex-direction: column;
            padding: 8px 10px;
            background-color: rgba(40, 40, 40, 0.7);
            border-radius: 5px;
            gap: 5px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        /* Modal Styles */
        #modal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-content {
            background-color: #282828;
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            font-size: 16px;
        }

        .modal-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        /* Main Menu Styles */
        #main-menu-screen {
             justify-content: center;
             align-items: center;
        }
        #main-menu {
            display: flex;
            flex-direction: column;
            padding: 20px;
            width: 100%;
            max-width: 350px;
            align-items: center;
            gap: 20px;
        }
        .menu-title { font-size: 28px; margin-bottom: 20px; text-align: center; }
        .menu-button { width: 100%; padding: 15px; font-size: 18px; }

        /* Saved Charts Screen Styles */
        #charts-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        #no-charts-message { text-align: center; padding: 20px; color: #aaa; }
        #charts-list {
            list-style: none;
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden; /* Clip items to rounded border */
        }
        .chart-item {
            padding: 12px 15px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chart-item:last-child { border-bottom: none; }
        .chart-item:hover { background-color: #333; }
        .chart-item-name { flex-grow: 1; margin-right: 10px; }
        .chart-item-details { font-size: 12px; color: #bbb; white-space: nowrap; }
        .chart-item button {
             flex-grow: 0; /* Don't grow delete button */
             padding: 5px 8px;
             font-size: 12px;
             margin-left: 10px;
        }

        /* Chart View Screen Header */
        #chart-name {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Back Button */
        .back-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: rgba(50, 50, 50, 0.6);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            z-index: 20; /* Above map, below modal */
            font-size: 16px;
            line-height: 1; /* Ensure consistent height */
        }
    </style>
</head>
<body class="noselect">

    <!-- Main Menu Screen -->
    <div id="main-menu-screen" class="screen active">
        <div id="main-menu">
            <h1 class="menu-title">Autocross Mapper</h1>
            <button class="menu-button primary" id="new-chart-button">Create New Chart</button>
            <button class="menu-button" id="saved-charts-button">View Saved Charts</button>
            <button class="menu-button warning" id="import-chart-button-main">Import Chart</button>
        </div>
    </div>

    <!-- Mapping Screen -->
    <div id="mapping-screen" class="screen">
        <div id="app">
            <button id="back-to-main-button" class="back-button">←</button>

            <div id="header">
                <div id="location-info">
                    Waiting for GPS...
                    <span id="accuracy-status" class="status-pill status-wait">WAIT</span>
                </div>
                <button id="save-button" class="primary" disabled>Save</button>
            </div>

            <div id="map-container">
                <canvas id="canvas"></canvas>
                <div id="current-location"></div>
                <div id="selected-cone-indicator" class="selected-cone-indicator">Pointer Cone Selected</div>
            </div>

            <div id="controls">
                <!-- GPS Accuracy Threshold Slider -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>GPS Accuracy Threshold:</span>
                        <span id="accuracy-threshold-value">10.0 m</span>
                    </div>
                    <input type="range" id="accuracy-threshold-slider" min="1" max="50" value="10" step="0.5">
                </div>

                <!-- Cone Type Selection -->
                <div class="control-row">
                    <button id="btn-pointer-cone" class="active">Pointer Cone</button>
                    <button id="btn-single-cone">Single Cone</button>
                </div>

                <!-- Tagging and Deleting -->
                <div class="control-row">
                    <button id="btn-tag-cone" class="primary" disabled>Tag Cone</button>
                    <button id="btn-delete-last-cone" class="danger">Delete Last</button>
                </div>

                <!-- Zoom Controls -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Zoom Level:</span>
                        <span id="zoom-value">1.0x</span>
                    </div>
                    <input type="range" id="zoom-slider" min="0.1" max="8" value="1" step="0.1">
                </div>

                <!-- World Rotation Controls -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Rotate World:</span>
                        <span id="rotation-value">0°</span>
                    </div>
                    <input type="range" id="world-rotation-slider" min="-180" max="180" value="0" step="1">
                </div>

                <!-- Pointer Cone Rotation Controls (conditionally displayed) -->
                <div id="pointer-rotation-container" class="slider-container" style="display:none;">
                    <div class="slider-label">
                        <span>Selected Pointer Rotation:</span>
                        <span id="pointer-rotation-value">0°</span>
                    </div>
                    <input type="range" id="pointer-rotation-slider" min="-180" max="180" value="0" step="1">
                </div>
            </div>
        </div>
    </div>

    <!-- Saved Charts Screen -->
    <div id="saved-charts-screen" class="screen">
         <div id="app">
            <button id="back-from-charts-button" class="back-button">←</button>

            <div id="header">
                <h2 style="text-align: center; flex-grow: 1;">Saved Charts</h2>
            </div>

            <div id="charts-container">
                <div id="no-charts-message">
                    No saved charts yet. Create one or import a chart.
                </div>
                <ul id="charts-list"></ul> <!-- Items added dynamically -->
            </div>

            <div id="controls">
                <div class="control-row">
                     <!-- Note: Export is handled per-chart now -->
                    <button id="import-chart-button-saved" class="primary">Import Chart</button>
                    <button id="delete-all-charts-button" class="danger">Delete All Charts</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart View Screen -->
    <div id="chart-view-screen" class="screen">
        <div id="app">
            <button id="back-from-chart-view-button" class="back-button">←</button>

            <div id="header">
                <h2 id="chart-name">Chart View</h2>
                 <button id="export-current-chart-button" class="warning">Export</button>
            </div>

            <div id="chart-map-container">
                <canvas id="chart-canvas"></canvas>
                 <!-- No blue dot or selection indicator needed here -->
            </div>

            <div id="controls">
                <!-- Zoom Controls for Chart View -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Zoom Level:</span>
                        <span id="chart-zoom-value">1.0x</span>
                    </div>
                    <input type="range" id="chart-zoom-slider" min="0.1" max="8" value="1" step="0.1">
                </div>

                <!-- World Rotation Controls for Chart View -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Rotate World:</span>
                        <span id="chart-rotation-value">0°</span>
                    </div>
                    <input type="range" id="chart-rotation-slider" min="-180" max="180" value="0" step="1">
                </div>
            </div>
        </div>
    </div>

    <!-- Save Chart Modal -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Save Chart</div>
            <input type="text" id="chart-name-input" class="modal-input" placeholder="Enter chart name">
            <div class="modal-actions">
                <button id="cancel-save" class="danger">Cancel</button>
                <button id="confirm-save" class="primary">Save</button>
            </div>
        </div>
    </div>

    <!-- File Input (Hidden) -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <script>
        // ==== Enums and Constants ====
        const ConeType = {
            STARTING: 'starting', // First cone placed
            POINTER: 'pointer',   // Cone with direction
            SINGLE: 'single'      // Standard cone marker
        };

        const METERS_PER_LATITUDE = 111111; // Approximate meters per degree latitude
        const START_CONE_RADIUS_PX = 8;     // Base radius in pixels at zoom 1
        const POINTER_CONE_RADIUS_PX = 8;
        const POINTER_CONE_RECT_WIDTH_PX = 16; // Length of pointer indicator
        const POINTER_CONE_RECT_HEIGHT_PX = 6; // Width of pointer indicator
        const SELECTION_PADDING_PX = 3;
        const SELECTION_LINE_WIDTH_PX = 2;

         // --- NEW Triangle Constants ---
         const POINTER_TRIANGLE_LENGTH_PX = 20; // How far the tip extends from the base line
        const POINTER_TRIANGLE_BASE_HALF_WIDTH_PX = 6; // Half the width of the triangle's base
        const POINTER_TRIANGLE_SIDE_OFFSET_Y_PX = 20 // How far from the center the base line sits
        // --- End NEW ---

        // ==== App State ====
        const state = {
            currentScreen: 'main-menu',
            selectedConeType: ConeType.POINTER,
            currentLocation: null, // { latitude, longitude, accuracy }
            cones: [],             // Array of Cone objects in the current mapping session
            selectedConeIndex: null, // Index of the cone selected for rotation/moving
            worldRotation: 0,      // Degrees, for mapping screen
            zoomScale: 1.0,        // Multiplier for mapping screen
            isDraggingMap: false,
            isDraggingCone: false,
            lastInteractionX: 0,
            lastInteractionY: 0,
            offsetX: 0,            // Map pan offset X (pixels)
            offsetY: 0,            // Map pan offset Y (pixels)
            gpsAccuracyThreshold: 10.0, // Meters
            isGPSReady: false,     // Combined check of location available and accuracy good
            savedCharts: [],       // Array of chart objects loaded from localStorage
            currentViewingChart: null, // { name, coneData, createdAt, worldRotation? }
            chartViewZoom: 1.0,
            chartViewRotation: 0,
            pointerConeRotation: 0, // Default/current rotation for NEW pointer cones
        };

        // ==== DOM Elements ====
        // Navigation & Screens
        const screens = {
            mainMenu: document.getElementById('main-menu-screen'),
            mapping: document.getElementById('mapping-screen'),
            savedCharts: document.getElementById('saved-charts-screen'),
            chartView: document.getElementById('chart-view-screen'),
        };
        const newChartButton = document.getElementById('new-chart-button');
        const savedChartsButton = document.getElementById('saved-charts-button');
        const backToMainButton = document.getElementById('back-to-main-button');
        const backFromChartsButton = document.getElementById('back-from-charts-button');
        const backFromChartViewButton = document.getElementById('back-from-chart-view-button');

        // Mapping Screen Elements
        const locationInfo = document.getElementById('location-info');
        const accuracyStatus = document.getElementById('accuracy-status');
        const saveButton = document.getElementById('save-button');
        const mappingCanvas = document.getElementById('canvas');
        const mappingCtx = mappingCanvas.getContext('2d');
        const currentLocationMarker = document.getElementById('current-location');
        const selectedConeIndicator = document.getElementById('selected-cone-indicator');
        const accuracyThresholdSlider = document.getElementById('accuracy-threshold-slider');
        const accuracyThresholdValue = document.getElementById('accuracy-threshold-value');
        const btnPointerCone = document.getElementById('btn-pointer-cone');
        const btnSingleCone = document.getElementById('btn-single-cone');
        const btnTagCone = document.getElementById('btn-tag-cone');
        const btnDeleteLastCone = document.getElementById('btn-delete-last-cone');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const worldRotationSlider = document.getElementById('world-rotation-slider');
        const rotationValue = document.getElementById('rotation-value');
        const pointerRotationContainer = document.getElementById('pointer-rotation-container');
        const pointerRotationSlider = document.getElementById('pointer-rotation-slider');
        const pointerRotationValue = document.getElementById('pointer-rotation-value');

        // Saved Charts Screen Elements
        const chartsContainer = document.getElementById('charts-container');
        const noChartsMessage = document.getElementById('no-charts-message');
        const chartsList = document.getElementById('charts-list');
        const importChartButtonMain = document.getElementById('import-chart-button-main');
        const importChartButtonSaved = document.getElementById('import-chart-button-saved');
        const deleteAllChartsButton = document.getElementById('delete-all-charts-button');

        // Chart View Screen Elements
        const chartViewCanvas = document.getElementById('chart-canvas');
        const chartViewCtx = chartViewCanvas.getContext('2d');
        const chartName = document.getElementById('chart-name');
        const exportCurrentChartButton = document.getElementById('export-current-chart-button');
        const chartZoomSlider = document.getElementById('chart-zoom-slider');
        const chartZoomValue = document.getElementById('chart-zoom-value');
        const chartRotationSlider = document.getElementById('chart-rotation-slider');
        const chartRotationValue = document.getElementById('chart-rotation-value');

        // Modal Elements
        const modal = document.getElementById('modal');
        const chartNameInput = document.getElementById('chart-name-input');
        const cancelSaveButton = document.getElementById('cancel-save');
        const confirmSaveButton = document.getElementById('confirm-save');

        // Hidden File Input
        const importFileInput = document.getElementById('import-file-input');

        // ==== Core Classes ====
        class Cone {
            // Store location in degrees lat/lon
            constructor(latitude, longitude, type = ConeType.SINGLE, rotation = 0) {
                this.latitude = latitude;
                this.longitude = longitude;
                this.type = type;
                this.rotation = rotation; // In degrees
                this.id = 'cone_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                // Screen coordinates updated during drawing calculations
                this.screenX = 0;
                this.screenY = 0;
            }
        }

        // ==== Utility Functions ====

        // Calculate meters per degree of longitude at a given latitude
        function metersPerDegreeLongitude(latitude) {
            return METERS_PER_LATITUDE * Math.cos(latitude * Math.PI / 180);
        }

        // Convert screen pixel coordinates (relative to canvas top-left) to geographic location
        // This needs to account for current GPS center, pan offset, zoom, and world rotation
        function screenToGeo(screenX, screenY) {
            if (!state.currentLocation) return null;

            const canvasWidth = mappingCanvas.width;
            const canvasHeight = mappingCanvas.height;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            // 1. Reverse World Rotation: Find the point relative to center *before* rotation
            const angleRad = -state.worldRotation * Math.PI / 180; // Reverse angle
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);
            const rotatedX = (screenX - centerX) * cosA - (screenY - centerY) * sinA + centerX;
            const rotatedY = (screenX - centerX) * sinA + (screenY - centerY) * cosA + centerY;

            // 2. Reverse Pan Offset: Find position relative to the GPS center marker
            const xFromCenter = rotatedX - centerX - state.offsetX;
            const yFromCenter = rotatedY - centerY - state.offsetY;

            // 3. Reverse Zoom: Calculate distance in meters
            const metersPerPixel = calculateMetersPerPixel();
            const metersX = xFromCenter * metersPerPixel;
            const metersY = yFromCenter * metersPerPixel; // Positive Y on screen is typically South

            // 4. Convert Meters to Lat/Lon Deltas
            const metersPerLon = metersPerDegreeLongitude(state.currentLocation.latitude);
            const deltaLon = metersX / metersPerLon;
            const deltaLat = -metersY / METERS_PER_LATITUDE; // Negative because screen Y increases downwards

            return {
                latitude: state.currentLocation.latitude + deltaLat,
                longitude: state.currentLocation.longitude + deltaLon
            };
        }

        // Convert geographic location to screen coordinates (relative to canvas top-left)
        // Needs reference location (usually current GPS), pan offset, zoom, world rotation
        function geoToScreen(coneLat, coneLon, refLat, refLon, currentOffsetX, currentOffsetY, currentZoom, currentRotation) {
            const canvasWidth = mappingCanvas.width; // Assume both canvases are sized same way
            const canvasHeight = mappingCanvas.height;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            // 1. Calculate Meter Offsets from Reference Location
            const metersPerLon = metersPerDegreeLongitude(refLat);
            const metersX = (coneLon - refLon) * metersPerLon;
            const metersY = -(coneLat - refLat) * METERS_PER_LATITUDE; // Negative for screen Y direction

            // 2. Apply Zoom: Convert meters to pixels relative to center
            const metersPerPixel = calculateMetersPerPixel(currentZoom);
            const pixelsX = metersX / metersPerPixel;
            const pixelsY = metersY / metersPerPixel;

            // 3. Apply Pan Offset: Position relative to canvas center + offset
            const initialX = centerX + currentOffsetX + pixelsX;
            const initialY = centerY + currentOffsetY + pixelsY;

            // 4. Apply World Rotation: Rotate around the canvas center
            const angleRad = currentRotation * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            const finalX = (initialX - centerX) * cosA - (initialY - centerY) * sinA + centerX;
            const finalY = (initialX - centerX) * sinA + (initialY - centerY) * cosA + centerY;

            return { x: finalX, y: finalY };
        }

        // Calculate map scale based on zoom
        function calculateMetersPerPixel(zoom = state.zoomScale) {
            // Define a base scale, e.g., 1 meter = 10 pixels at zoom 1.0
            const basePixelsPerMeter = 10;
            return 1 / (basePixelsPerMeter * zoom);
        }


        // Update screenX/screenY for all cones based on current state (GPS, pan, zoom, rotation)
        // This is primarily for hit detection and potentially for moving cones.
        function updateConeScreenPositions() {
            if (!state.currentLocation) return;

            state.cones.forEach(cone => {
                const screenPos = geoToScreen(
                    cone.latitude, cone.longitude,
                    state.currentLocation.latitude, state.currentLocation.longitude,
                    state.offsetX, state.offsetY, state.zoomScale, state.worldRotation
                );
                cone.screenX = screenPos.x;
                cone.screenY = screenPos.y;
            });
        }

        // Find cone index at screen coordinates
        function findConeAt(screenX, screenY) {
             if (!state.currentLocation) return null;
             const hitRadius = Math.max(START_CONE_RADIUS_PX, POINTER_CONE_RADIUS_PX) * state.zoomScale + 5; // Generous hit radius

             // Iterate backwards (last drawn cone is on top)
            for (let i = state.cones.length - 1; i >= 0; i--) {
                const cone = state.cones[i];
                // Need to calculate screen pos on the fly for hit test, as offsetX/Y might have changed
                 const coneScreenPos = geoToScreen(
                    cone.latitude, cone.longitude,
                    state.currentLocation.latitude, state.currentLocation.longitude,
                    state.offsetX, state.offsetY, state.zoomScale, state.worldRotation
                 );

                 // Simple distance check is usually sufficient for selection
                const dx = screenX - coneScreenPos.x;
                const dy = screenY - coneScreenPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= hitRadius) {
                    return i; // Return index of the found cone
                }
            }
            return null; // No cone found
        }

        // ==== Drawing Functions ====

        function drawCones(context, conesToDraw, refLocation, offsetX, offsetY, zoom, rotation) {
            if (!refLocation) return;

            const canvasWidth = context.canvas.width;
            const canvasHeight = context.canvas.height;

            conesToDraw.forEach((cone, index) => {
                 // Calculate screen position for drawing THIS cone based on view parameters
                 const screenPos = geoToScreen(
                    cone.latitude, cone.longitude,
                    refLocation.latitude, refLocation.longitude,
                    offsetX, offsetY, zoom, rotation // Pass world rotation here
                );

                const isSelected = (context === mappingCtx && index === state.selectedConeIndex); // Selection only on mapping screen

                context.save(); // Save context state before drawing each cone

                // --- Apply individual cone rotation ONLY for pointer cones ---
                let coneRotationRad = 0;
                if (cone.type === ConeType.POINTER) {
                    coneRotationRad = cone.rotation * Math.PI / 180;
                }

                // Translate to the calculated screen position first
                context.translate(screenPos.x, screenPos.y);
                // Then rotate the context for this specific cone (if it's a pointer)
                context.rotate(coneRotationRad);

                // --- Draw the cone shape relative to the new (0,0) origin, now rotated ---

                if (cone.type === ConeType.STARTING) {
                    const radius = START_CONE_RADIUS_PX * zoom;
                    context.beginPath();
                    context.fillStyle = 'green';
                    context.arc(0, 0, radius, 0, Math.PI * 2);
                    context.fill();
                    if (isSelected) {
                        context.strokeStyle = 'lime';
                        context.lineWidth = SELECTION_LINE_WIDTH_PX * zoom;
                        context.beginPath();
                        context.arc(0, 0, radius + SELECTION_PADDING_PX * zoom, 0, Math.PI * 2);
                        context.stroke();
                    }
                } else if (cone.type === ConeType.POINTER) {
                    const baseRadius = POINTER_CONE_RADIUS_PX * zoom;
                    // --- Triangle Calculations ---
                    const triLength = POINTER_TRIANGLE_LENGTH_PX * zoom;
                    const triBaseHalfWidth = POINTER_TRIANGLE_BASE_HALF_WIDTH_PX * zoom;
                    const triangleOffsetY = POINTER_TRIANGLE_SIDE_OFFSET_Y_PX * zoom;

                    // Define triangle points relative to (0, triangleOffsetY)
                    // *** REVERSED ORIENTATION ***
                    const triTipX = 0;          // Tip is now at X=0 (pointing towards center)
                    const triBaseX = triLength; // Base is further out along positive X

                    // 1. Draw the base circle (at 0,0)
                    context.beginPath();
                    context.fillStyle = 'orange';
                    context.arc(0, 0, baseRadius, 0, Math.PI * 2);
                    context.fill();

                    // 2. Draw the direction indicator TRIANGLE (offset downwards, pointing inwards)
                    context.fillStyle = 'red';
                    context.beginPath();
                    // Start at the tip (now at X=0)
                    context.moveTo(triTipX, triangleOffsetY);
                    // Line to the two base corners (now further out at X=triBaseX)
                    context.lineTo(triBaseX, triangleOffsetY - triBaseHalfWidth);
                    context.lineTo(triBaseX, triangleOffsetY + triBaseHalfWidth);
                    context.closePath(); // Line back to the tip
                    context.fill();

                    // 3. Draw selection indicator if selected
                    if (isSelected) {
                        context.beginPath();
                        context.strokeStyle = 'lime';
                        context.lineWidth = SELECTION_LINE_WIDTH_PX * zoom;
                        // Calculate radius needed to encompass both base and offset triangle
                        const max_x = Math.max(baseRadius, triBaseX); // Furthest X point is the triangle base
                        const max_y = Math.max(baseRadius, Math.abs(triangleOffsetY) + triBaseHalfWidth); // Furthest Y point (use absolute offset)
                        const selectionRadius = Math.sqrt(max_x * max_x + max_y * max_y) + SELECTION_PADDING_PX * zoom;
                        // Draw the encompassing circle centered at the base cone (0,0)
                        context.arc(0, 0, selectionRadius, 0, Math.PI * 2);
                        context.stroke();
                    }
                } else { // ConeType.SINGLE
                    const radius = POINTER_CONE_RADIUS_PX * zoom; // Same size as pointer base
                    context.beginPath();
                    context.fillStyle = 'orange';
                    context.arc(0, 0, radius, 0, Math.PI * 2);
                    context.fill();
                    if (isSelected) {
                        context.strokeStyle = 'lime';
                        context.lineWidth = SELECTION_LINE_WIDTH_PX * zoom;
                        context.beginPath();
                        context.arc(0, 0, radius + SELECTION_PADDING_PX * zoom, 0, Math.PI * 2);
                        context.stroke();
                    }
                }

                context.restore(); // Restore context state (removes translate and rotate for next cone)
            });
        }
        


        function drawMap() {
            const canvasWidth = mappingCanvas.width;
            const canvasHeight = mappingCanvas.height;
            mappingCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Optional: Draw grid or background elements first

            if (state.currentLocation) {
                // Draw cones relative to current GPS location, considering pan, zoom, and world rotation
                drawCones(
                    mappingCtx,
                    state.cones,
                    state.currentLocation,
                    state.offsetX,
                    state.offsetY,
                    state.zoomScale,
                    state.worldRotation // Use the mapping screen's world rotation
                );
            }

            // Update marker visibility based on GPS status
            currentLocationMarker.style.display = state.currentLocation ? 'block' : 'none';
        }


        function drawChartView() {
            if (!state.currentViewingChart || state.currentViewingChart.coneData.length === 0) {
                chartViewCtx.clearRect(0, 0, chartViewCanvas.width, chartViewCanvas.height);
                return; // Nothing to draw
            }

            const chart = state.currentViewingChart;
            const canvasWidth = chartViewCanvas.width;
            const canvasHeight = chartViewCanvas.height;
            chartViewCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Use the first cone as the reference point (center of the view initially)
            const referenceLocation = {
                latitude: chart.coneData[0].latitude,
                longitude: chart.coneData[0].longitude
            };

            // Center the view on the first cone, apply chart-specific zoom and rotation
            // For chart view, pan offset (offsetX/Y) is typically 0, centering on the first cone.
             drawCones(
                chartViewCtx,
                chart.coneData,
                referenceLocation,
                0, // No panning in chart view (usually)
                0, // No panning in chart view (usually)
                state.chartViewZoom,
                state.chartViewRotation // Use chart view's rotation
            );
        }

        // Resize canvas elements to fill their containers
        function resizeCanvas() {
            const mapContainer = mappingCanvas.parentElement;
            if (mapContainer) {
                mappingCanvas.width = mapContainer.clientWidth;
                mappingCanvas.height = mapContainer.clientHeight;
            }

            const chartContainer = chartViewCanvas.parentElement;
            if (chartContainer) {
                chartViewCanvas.width = chartContainer.clientWidth;
                chartViewCanvas.height = chartContainer.clientHeight;
            }

             // Redraw relevant canvases after resize
            if (state.currentScreen === 'mapping') {
                 updateConeScreenPositions(); // Recalculate positions based on new size
                 drawMap();
            } else if (state.currentScreen === 'chart-view') {
                 drawChartView();
            }
        }

        // ==== Cone Management Functions ====

        function tagCone() {
            if (!state.currentLocation || !state.isGPSReady) {
                 alert("GPS location not available or accuracy too low.");
                 return;
            }

            let coneType = state.selectedConeType;
            let coneRotation = 0;

            if (state.cones.length === 0) {
                coneType = ConeType.STARTING; // First cone is always starting cone
            } else if (coneType === ConeType.POINTER) {
                 coneRotation = state.pointerConeRotation; // Use current slider value for new pointer
            }

            const newCone = new Cone(
                state.currentLocation.latitude,
                state.currentLocation.longitude,
                coneType,
                coneRotation
            );

            state.cones.push(newCone);

            // If it was a pointer cone, select it immediately
            if (coneType === ConeType.POINTER) {
                selectCone(state.cones.length - 1);
            } else {
                 deselectCone(); // Deselect if adding a single cone
            }

            updateConeScreenPositions(); // Update screen coords for all cones
            drawMap();
            updateSaveButtonState(); // Enable save button if cones exist
        }

        function deleteLastCone() {
            if (state.cones.length > 0) {
                const deletedConeIndex = state.cones.length - 1;
                state.cones.pop();

                // If the deleted cone was the selected one, deselect
                if (state.selectedConeIndex === deletedConeIndex) {
                    deselectCone(); // This also hides the rotation slider
                } else if (state.selectedConeIndex > deletedConeIndex) {
                    // Adjust selection index if needed (though pop only affects the last)
                     state.selectedConeIndex--;
                 }

                drawMap();
                updateSaveButtonState(); // Disable save button if no cones left
            }
        }

        function selectCone(index) {
             if (index === null || index < 0 || index >= state.cones.length) {
                 deselectCone();
                 return;
             }

            state.selectedConeIndex = index;
            const cone = state.cones[index];

            if (cone.type === ConeType.POINTER) {
                // Update and show the rotation slider
                state.pointerConeRotation = cone.rotation; // Sync state
                pointerRotationSlider.value = cone.rotation;
                pointerRotationValue.textContent = `${Math.round(cone.rotation)}°`;
                pointerRotationContainer.style.display = 'flex'; // Show the slider container
                selectedConeIndicator.style.display = 'block'; // Show the indicator text
            } else {
                // Hide rotation controls if not a pointer cone
                pointerRotationContainer.style.display = 'none';
                selectedConeIndicator.style.display = 'none';
            }

            drawMap(); // Redraw to show selection highlight
        }

        function deselectCone() {
            state.selectedConeIndex = null;
            pointerRotationContainer.style.display = 'none'; // Hide slider
            selectedConeIndicator.style.display = 'none'; // Hide indicator
            drawMap(); // Redraw to remove selection highlight
        }

         // Updates the rotation of the currently selected cone
         function updateSelectedConeRotation(rotation) {
             if (state.selectedConeIndex !== null && state.cones[state.selectedConeIndex].type === ConeType.POINTER) {
                 state.cones[state.selectedConeIndex].rotation = rotation;
                 // state.pointerConeRotation = rotation; // Keep this synced for new cones
                 // pointerRotationValue.textContent = `${Math.round(rotation)}°`; // Listener updates this
                 drawMap(); // Redraw to show the change
            }
         }

         // Move the selected cone based on drag delta
         function moveSelectedCone(deltaX, deltaY) {
            if (state.selectedConeIndex === null) return;

            const cone = state.cones[state.selectedConeIndex];
            const currentScreenPos = geoToScreen(
                cone.latitude, cone.longitude,
                state.currentLocation.latitude, state.currentLocation.longitude,
                state.offsetX, state.offsetY, state.zoomScale, state.worldRotation
            );

            const newScreenX = currentScreenPos.x + deltaX;
            const newScreenY = currentScreenPos.y + deltaY;

            const newGeo = screenToGeo(newScreenX, newScreenY);

            if (newGeo) {
                cone.latitude = newGeo.latitude;
                cone.longitude = newGeo.longitude;
                // Update internal screen pos for immediate feedback before full redraw
                cone.screenX = newScreenX;
                cone.screenY = newScreenY;
                 drawMap(); // Redraw to show moved cone
            }
        }

         // Update Save Button state based on whether cones exist
        function updateSaveButtonState() {
             saveButton.disabled = state.cones.length === 0;
         }


        // ==== Geolocation Functions ====
        let watchId = null;

        function initGeolocation() {
            if ('geolocation' in navigator) {
                // Clear any previous watch
                if (watchId !== null) {
                    navigator.geolocation.clearWatch(watchId);
                }

                 updateLocationStatus("WAIT", "Requesting GPS...");
                 currentLocationMarker.style.display = 'none'; // Hide until first fix
                 state.currentLocation = null; // Reset location on init
                 state.isGPSReady = false;
                 btnTagCone.disabled = true;


                // Get initial high-accuracy position
                navigator.geolocation.getCurrentPosition(
                    handleLocationUpdate,
                    handleLocationError,
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
                );

                // Start watching for continuous updates
                watchId = navigator.geolocation.watchPosition(
                    handleLocationUpdate,
                    handleLocationError,
                    { enableHighAccuracy: true, maximumAge: 2000, timeout: 5000 } // Update more frequently
                );
            } else {
                updateLocationStatus("BAD", "Geolocation not supported");
                btnTagCone.disabled = true;
            }
        }

        function stopGeolocation() {
            if (watchId !== null && navigator.geolocation) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                 updateLocationStatus("BAD", "GPS Disabled");
                 currentLocationMarker.style.display = 'none';
                 state.isGPSReady = false;
                 btnTagCone.disabled = true;
            }
        }


        function handleLocationUpdate(position) {
            state.currentLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy // Accuracy in meters
            };

             const accuracyMeters = position.coords.accuracy;
             state.isGPSReady = accuracyMeters <= state.gpsAccuracyThreshold;

             const latStr = position.coords.latitude.toFixed(6);
             const lonStr = position.coords.longitude.toFixed(6);
             const accStr = accuracyMeters.toFixed(1);

             let statusText = `Lat:${latStr}, Lon:${lonStr} | Acc:${accStr}m`;

            if (state.isGPSReady) {
                 updateLocationStatus("GOOD", "OK", statusText);
                 btnTagCone.disabled = false;
            } else {
                updateLocationStatus("BAD", "ACC POOR", statusText);
                 btnTagCone.disabled = true;
            }

            // Update cone screen positions if map is panned/zoomed
            updateConeScreenPositions();
            drawMap(); // Redraw map with new center
        }


        function handleLocationError(error) {
            console.error('Geolocation Error:', error.code, error.message);
             let message = 'GPS Error';
             switch(error.code) {
                case error.PERMISSION_DENIED: message = "GPS Permission Denied"; break;
                case error.POSITION_UNAVAILABLE: message = "GPS Position Unavailable"; break;
                case error.TIMEOUT: message = "GPS Timeout"; break;
            }
             updateLocationStatus("BAD", "ERROR", message);
             state.currentLocation = null;
             state.isGPSReady = false;
             btnTagCone.disabled = true;
             currentLocationMarker.style.display = 'none';
             drawMap(); // Redraw (clears cones if no location)
        }

        function updateLocationStatus(statusType, statusLabel, infoText = "Waiting for GPS...") {
             accuracyStatus.textContent = statusLabel;
             locationInfo.innerHTML = `${infoText} <span id="accuracy-status" class="status-pill status-${statusType.toLowerCase()}">${statusLabel}</span>`;
             // Re-fetch the span element as innerHTML replaces it
             // accuracyStatus = document.getElementById('accuracy-status'); // Not strictly needed if just updating text/class
              const statusPill = locationInfo.querySelector('.status-pill');
              if(statusPill) {
                   statusPill.className = `status-pill status-${statusType.toLowerCase()}`;
                   statusPill.textContent = statusLabel;
              }
        }

        // ==== Storage Functions ====
        const STORAGE_KEY = 'autocrossCharts';

        function saveCurrentChart(name) {
            if (state.cones.length === 0) {
                alert('No cones to save!');
                return false;
            }

            const chartData = {
                name: name,
                // Deep copy cone data to avoid storing screenX/Y or modifying original objects later
                 coneData: state.cones.map(c => ({
                    latitude: c.latitude,
                    longitude: c.longitude,
                    type: c.type,
                    rotation: c.rotation,
                    id: c.id // Keep ID for potential future use
                })),
                worldRotation: state.worldRotation, // Save the world rotation at time of save
                createdAt: new Date().toISOString()
            };

            loadSavedCharts(); // Load current list
            state.savedCharts.push(chartData); // Add the new one

            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));
                alert(`Chart "${name}" saved successfully!`);
                return true;
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                alert("Error saving chart. Storage might be full.");
                // Remove the chart we optimistically added if save failed
                 state.savedCharts.pop();
                 return false;
            }
        }

        function loadSavedCharts() {
            try {
                const storedCharts = localStorage.getItem(STORAGE_KEY);
                if (storedCharts) {
                    // Basic validation: Check if it's an array
                     const parsed = JSON.parse(storedCharts);
                     if (Array.isArray(parsed)) {
                         state.savedCharts = parsed;
                     } else {
                         console.error("Stored chart data is not an array. Resetting.");
                         state.savedCharts = [];
                         localStorage.removeItem(STORAGE_KEY);
                     }
                } else {
                    state.savedCharts = [];
                }
            } catch (e) {
                console.error("Error loading charts from localStorage:", e);
                state.savedCharts = []; // Reset on error
            }
             return state.savedCharts;
        }

         function deleteChart(chartNameToDelete) {
            if (!confirm(`Are you sure you want to delete the chart "${chartNameToDelete}"? This cannot be undone.`)) {
                 return;
            }
             loadSavedCharts();
             state.savedCharts = state.savedCharts.filter(chart => chart.name !== chartNameToDelete);
             try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));
                updateChartsList(); // Refresh the list display
            } catch (e) {
                 console.error("Error saving updated charts list:", e);
                 alert("Error deleting chart from storage.");
                 loadSavedCharts(); // Reload to revert optimistic deletion
            }
         }

         function deleteAllCharts() {
             if (state.savedCharts.length === 0) {
                 alert("There are no charts to delete.");
                 return;
             }
             if (!confirm("Are you sure you want to delete ALL saved charts? This cannot be undone.")) {
                 return;
             }
             state.savedCharts = [];
             try {
                 localStorage.removeItem(STORAGE_KEY); // More efficient than saving empty array
                 updateChartsList();
             } catch (e) {
                 console.error("Error deleting all charts:", e);
                 alert("Error clearing chart storage.");
                 loadSavedCharts(); // Revert
             }
         }

        function exportChart(chart) {
             if (!chart) {
                 alert("No chart selected for export.");
                 return;
             }
            try {
                 // Use only essential data for export
                 const exportData = {
                     name: chart.name,
                     coneData: chart.coneData.map(c => ({ // Ensure clean export
                         latitude: c.latitude,
                         longitude: c.longitude,
                         type: c.type,
                         rotation: c.rotation
                     })),
                     worldRotation: chart.worldRotation || 0,
                     createdAt: chart.createdAt
                 };

                const chartJson = JSON.stringify(exportData, null, 2); // Pretty print JSON
                const blob = new Blob([chartJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                // Sanitize filename
                 const filename = chart.name.replace(/[^a-z0-9_ -]/gi, '_').replace(/\s+/g, '_');
                 a.download = `${filename || 'autocross_chart'}.json`;
                document.body.appendChild(a); // Required for Firefox
                a.click();
                document.body.removeChild(a);

                // Delay revokeObjectURL slightly
                setTimeout(() => URL.revokeObjectURL(url), 100);
             } catch (error) {
                 console.error("Error exporting chart:", error);
                 alert("Could not export chart data.");
             }
        }

        function importChartFromFile(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // **Basic Validation**
                    if (typeof importedData !== 'object' || importedData === null) throw new Error("Invalid file format (not an object).");
                    if (typeof importedData.name !== 'string' || !importedData.name.trim()) throw new Error("Chart name missing or invalid.");
                    if (!Array.isArray(importedData.coneData)) throw new Error("Invalid cone data format (not an array).");
                    if (importedData.coneData.length === 0) throw new Error("Chart contains no cones.");

                    // Further validation for cone data structure (optional but recommended)
                    for(const cone of importedData.coneData) {
                         if (typeof cone.latitude !== 'number' || typeof cone.longitude !== 'number' || typeof cone.type !== 'string') {
                             throw new Error("Invalid data structure within coneData.");
                         }
                         // Assign default rotation if missing
                         cone.rotation = typeof cone.rotation === 'number' ? cone.rotation : 0;
                    }

                     // Check for name collision
                     loadSavedCharts();
                     const existingChart = state.savedCharts.find(c => c.name === importedData.name);
                     if (existingChart) {
                         if (!confirm(`A chart named "${importedData.name}" already exists. Overwrite it?`)) {
                             alert("Import cancelled.");
                             return;
                         }
                         // Remove existing chart before adding new one
                          state.savedCharts = state.savedCharts.filter(c => c.name !== importedData.name);
                     }


                    // Add necessary fields if missing from older exports
                     const newChart = {
                         ...importedData,
                         worldRotation: importedData.worldRotation || 0,
                         createdAt: importedData.createdAt || new Date().toISOString() // Add created date if missing
                     };

                    state.savedCharts.push(newChart);

                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));

                    alert(`Chart "${newChart.name}" imported successfully!`);
                    updateChartsList(); // Refresh list in case user is on that screen

                } catch (error) {
                    console.error("Error importing chart:", error);
                    alert('Error importing chart: ' + error.message);
                } finally {
                    // Reset file input value so the same file can be selected again if needed
                     importFileInput.value = '';
                 }
            };

             reader.onerror = function() {
                 alert('Error reading the selected file.');
                 importFileInput.value = '';
             };

            reader.readAsText(file);
        }

        function triggerImport() {
             importFileInput.click(); // Open file selection dialog
         }


        function updateChartsList() {
            loadSavedCharts(); // Ensure state.savedCharts is up-to-date

            if (state.savedCharts.length === 0) {
                noChartsMessage.style.display = 'block';
                chartsList.style.display = 'none';
                chartsList.innerHTML = ''; // Clear list
            } else {
                noChartsMessage.style.display = 'none';
                chartsList.style.display = 'block';
                chartsList.innerHTML = ''; // Clear previous items

                // Sort charts, e.g., by creation date descending
                const sortedCharts = [...state.savedCharts].sort((a, b) => {
                     const dateA = a.createdAt ? new Date(a.createdAt) : 0;
                     const dateB = b.createdAt ? new Date(b.createdAt) : 0;
                     return dateB - dateA; // Newest first
                 });


                sortedCharts.forEach(chart => {
                    const li = document.createElement('li');
                    li.className = 'chart-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'chart-item-name';
                    nameSpan.textContent = chart.name;

                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'chart-item-details';
                    let dateStr = 'Unknown date';
                    if (chart.createdAt) {
                         try { dateStr = new Date(chart.createdAt).toLocaleDateString(); } catch (e) {}
                     }
                    detailsSpan.textContent = `${chart.coneData.length} cones (${dateStr})`;

                     const deleteBtn = document.createElement('button');
                     deleteBtn.className = 'danger';
                     deleteBtn.textContent = 'Del';
                     deleteBtn.onclick = (e) => {
                         e.stopPropagation(); // Prevent li click event when clicking button
                         deleteChart(chart.name);
                     };

                    li.appendChild(nameSpan);
                    li.appendChild(detailsSpan);
                    li.appendChild(deleteBtn);

                    li.addEventListener('click', () => {
                        viewChart(chart);
                    });

                    chartsList.appendChild(li);
                });
            }
        }

        function viewChart(chart) {
            state.currentViewingChart = chart;

            chartName.textContent = chart.name;

             // Set initial view state from chart or defaults
            state.chartViewRotation = chart.worldRotation || 0; // Use saved rotation
            state.chartViewZoom = 1.0; // Start zoom at 1x

            chartRotationSlider.value = state.chartViewRotation;
            chartRotationValue.textContent = `${Math.round(state.chartViewRotation)}°`;
            chartZoomSlider.value = state.chartViewZoom;
            chartZoomValue.textContent = `${state.chartViewZoom.toFixed(1)}x`;

            navigateToScreen('chartView'); // Navigate AFTER setting state
        }

        function generateChartName() {
            const now = new Date();
            const date = now.toISOString().split('T')[0];
            const time = now.toTimeString().split(' ')[0].replace(/:/g, '-');
            return `Chart_${date}_${time}`;
        }

        // ==== Navigation ====
        function navigateToScreen(screenId) {
            // Hide all screens
            Object.values(screens).forEach(screen => screen.classList.remove('active'));

            // Show the target screen
             if (screens[screenId]) {
                 screens[screenId].classList.add('active');
                 state.currentScreen = screenId;

                // Screen-specific setup
                switch(screenId) {
                    case 'mapping':
                         // Reset map state for a new session
                         state.cones = [];
                         state.offsetX = 0;
                         state.offsetY = 0;
                         state.zoomScale = 1.0;
                         state.worldRotation = 0;
                         state.selectedConeIndex = null;
                         zoomSlider.value = state.zoomScale;
                         zoomValue.textContent = `${state.zoomScale.toFixed(1)}x`;
                         worldRotationSlider.value = state.worldRotation;
                         rotationValue.textContent = `${Math.round(state.worldRotation)}°`;
                         deselectCone(); // Ensure rotation slider is hidden initially
                         updateSaveButtonState(); // Disable save initially
                        resizeCanvas(); // Ensure canvas fits container
                        initGeolocation(); // Start GPS tracking
                        break;
                    case 'savedCharts':
                        stopGeolocation(); // Stop GPS when leaving mapping screen
                        updateChartsList(); // Load and display saved charts
                        break;
                    case 'chartView':
                         stopGeolocation();
                         resizeCanvas(); // Ensure canvas fits
                         drawChartView(); // Draw the selected chart
                        break;
                    case 'mainMenu':
                         stopGeolocation();
                         state.currentViewingChart = null; // Clear viewed chart
                         state.cones = []; // Clear any leftover mapping cones
                         break;
                 }
            } else {
                 console.error("Screen ID not found:", screenId);
             }
        }

        // ==== Event Handlers ====

        // -- Canvas Interaction (Mapping Screen) --
        function getCanvasCoords(event) {
            const rect = mappingCanvas.getBoundingClientRect();
             let clientX, clientY;
             if (event.touches && event.touches.length > 0) {
                 clientX = event.touches[0].clientX;
                 clientY = event.touches[0].clientY;
             } else if (event.changedTouches && event.changedTouches.length > 0) {
                 // Use changedTouches for touchend
                 clientX = event.changedTouches[0].clientX;
                 clientY = event.changedTouches[0].clientY;
            } else {
                 clientX = event.clientX;
                 clientY = event.clientY;
             }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handlePointerDown(event) {
            event.preventDefault(); // Prevent default touch actions like scrolling
            const coords = getCanvasCoords(event);
            state.lastInteractionX = coords.x;
            state.lastInteractionY = coords.y;

            const tappedConeIndex = findConeAt(coords.x, coords.y);

            if (tappedConeIndex !== null) {
                // Start dragging the selected cone
                 selectCone(tappedConeIndex); // Select the cone
                 state.isDraggingCone = true;
                 state.isDraggingMap = false;
                 mappingCanvas.style.cursor = 'grabbing';
            } else {
                // Start dragging the map
                 deselectCone(); // Deselect any cone if clicking empty space
                 state.isDraggingMap = true;
                 state.isDraggingCone = false;
                 mappingCanvas.style.cursor = 'grabbing';
            }
        }

        function handlePointerMove(event) {
            if (!state.isDraggingMap && !state.isDraggingCone) return;
            event.preventDefault();

            const coords = getCanvasCoords(event);
            const deltaX = coords.x - state.lastInteractionX;
            const deltaY = coords.y - state.lastInteractionY;

            if (state.isDraggingMap) {
                state.offsetX += deltaX;
                state.offsetY += deltaY;
                 // No need to update cone screen positions constantly during drag
                 drawMap(); // Redraw map with new offset
            } else if (state.isDraggingCone) {
                 // Move the selected cone
                 moveSelectedCone(deltaX, deltaY);
                 // moveSelectedCone calls drawMap internally
            }

            state.lastInteractionX = coords.x;
            state.lastInteractionY = coords.y;
        }

        function handlePointerUp(event) {
             if (state.isDraggingMap || state.isDraggingCone) {
                event.preventDefault();
                 // If just finished dragging, update final screen positions
                 // updateConeScreenPositions(); // Good idea after a drag ends
                 // drawMap(); // Ensure final state is drawn
             }
             state.isDraggingMap = false;
             state.isDraggingCone = false;
             mappingCanvas.style.cursor = 'grab'; // Reset cursor
         }


        // -- Button Clicks --
        newChartButton.addEventListener('click', () => navigateToScreen('mapping'));
        savedChartsButton.addEventListener('click', () => navigateToScreen('savedCharts'));
        backToMainButton.addEventListener('click', () => navigateToScreen('mainMenu'));
        backFromChartsButton.addEventListener('click', () => navigateToScreen('mainMenu'));
        backFromChartViewButton.addEventListener('click', () => navigateToScreen('savedCharts'));

        btnPointerCone.addEventListener('click', () => {
            state.selectedConeType = ConeType.POINTER;
            btnPointerCone.classList.add('active');
            btnSingleCone.classList.remove('active');
        });

        btnSingleCone.addEventListener('click', () => {
            state.selectedConeType = ConeType.SINGLE;
            btnSingleCone.classList.add('active');
            btnPointerCone.classList.remove('active');
            // When switching to single cone, deselect any currently selected cone
            // as the rotation slider doesn't apply to single cones.
             // deselectCone(); // Let user keep selection if they want? Maybe not needed.
        });

        btnTagCone.addEventListener('click', tagCone);
        btnDeleteLastCone.addEventListener('click', deleteLastCone);
        saveButton.addEventListener('click', () => {
             if (state.cones.length > 0) {
                 chartNameInput.value = generateChartName(); // Pre-fill name
                 modal.style.display = 'flex'; // Show save modal
             }
         });

         deleteAllChartsButton.addEventListener('click', deleteAllCharts);

         // Import buttons
         importChartButtonMain.addEventListener('click', triggerImport);
         importChartButtonSaved.addEventListener('click', triggerImport);
         importFileInput.addEventListener('change', (event) => {
             if (event.target.files.length > 0) {
                 importChartFromFile(event.target.files[0]);
             }
         });

         // Export button (in chart view)
         exportCurrentChartButton.addEventListener('click', () => {
             exportChart(state.currentViewingChart);
         });

        // -- Slider Inputs --
        accuracyThresholdSlider.addEventListener('input', () => {
            state.gpsAccuracyThreshold = parseFloat(accuracyThresholdSlider.value);
            accuracyThresholdValue.textContent = `${state.gpsAccuracyThreshold.toFixed(1)} m`;
            // Re-evaluate GPS readiness with the new threshold
            if (state.currentLocation) {
                 handleLocationUpdate({ coords: state.currentLocation }); // Fake update to re-check accuracy
             }
        });

        zoomSlider.addEventListener('input', () => {
            state.zoomScale = parseFloat(zoomSlider.value);
            zoomValue.textContent = `${state.zoomScale.toFixed(1)}x`;
             // updateConeScreenPositions(); // Update positions based on new zoom for hit detection
            drawMap();
        });

        worldRotationSlider.addEventListener('input', () => {
            state.worldRotation = parseFloat(worldRotationSlider.value);
            rotationValue.textContent = `${Math.round(state.worldRotation)}°`;
            // updateConeScreenPositions(); // Update positions based on new rotation
            drawMap();
        });

        pointerRotationSlider.addEventListener('input', () => {
             const rotation = parseFloat(pointerRotationSlider.value);
             state.pointerConeRotation = rotation; // Update default for next cone
             pointerRotationValue.textContent = `${Math.round(rotation)}°`;
             updateSelectedConeRotation(rotation); // Update the currently selected cone
         });

        // Chart View Sliders
        chartZoomSlider.addEventListener('input', () => {
            state.chartViewZoom = parseFloat(chartZoomSlider.value);
            chartZoomValue.textContent = `${state.chartViewZoom.toFixed(1)}x`;
            drawChartView();
        });

        chartRotationSlider.addEventListener('input', () => {
            state.chartViewRotation = parseFloat(chartRotationSlider.value);
            chartRotationValue.textContent = `${Math.round(state.chartViewRotation)}°`;
            drawChartView();
        });

        // -- Modal Actions --
        confirmSaveButton.addEventListener('click', () => {
            const name = chartNameInput.value.trim();
            if (!name) {
                alert('Please enter a valid chart name.');
                return;
            }
             // Check for name collision before saving
             loadSavedCharts();
             const existing = state.savedCharts.find(c => c.name === name);
             if (existing) {
                 if (!confirm(`A chart named "${name}" already exists. Overwrite it?`)) {
                     return; // Don't save, leave modal open
                 }
                 // Remove existing before saving new one
                  state.savedCharts = state.savedCharts.filter(c => c.name !== name);
             }


            if (saveCurrentChart(name)) {
                 modal.style.display = 'none'; // Hide modal on success
                 // Optionally navigate back or stay
                 // navigateToScreen('mainMenu');
             }
        });

        cancelSaveButton.addEventListener('click', () => {
            modal.style.display = 'none';
        });


        // ==== Initialization ====
        function initApp() {
             // Set cursor style
             mappingCanvas.style.cursor = 'grab';

            // Attach canvas listeners
            mappingCanvas.addEventListener('mousedown', handlePointerDown);
            mappingCanvas.addEventListener('mousemove', handlePointerMove);
            mappingCanvas.addEventListener('mouseup', handlePointerUp);
            mappingCanvas.addEventListener('mouseleave', handlePointerUp); // End drag if mouse leaves canvas

            // Use passive: false ONLY if preventDefault is called inside handler
            mappingCanvas.addEventListener('touchstart', handlePointerDown, { passive: false });
            mappingCanvas.addEventListener('touchmove', handlePointerMove, { passive: false });
            mappingCanvas.addEventListener('touchend', handlePointerUp, { passive: false });
            mappingCanvas.addEventListener('touchcancel', handlePointerUp, { passive: false }); // Treat cancel like end

            // Initial setup
            loadSavedCharts(); // Load charts on app start
            resizeCanvas(); // Size canvases correctly
            navigateToScreen('mainMenu'); // Start at the main menu

            // Add listener for window resize
            window.addEventListener('resize', resizeCanvas);

            console.log("Autocross Mapper Initialized");
        }

        // Start the app when the DOM is fully loaded
        window.addEventListener('load', initApp);

    </script>
</body>
</html>
