<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Autocross Mapper (Leaflet + World Rotation + Hidden BG Default)</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet Rotated Marker Plugin -->
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>

    <style>
        /* Basic Reset & Box Sizing */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: Arial, sans-serif; background-color: #000; color: #fff; }
        .noselect { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }

        /* Screen Management */
        .screen { display: none; width: 100%; height: 100%; overflow: hidden; flex-direction: column; }
        .screen.active { display: flex; }

        /* Main App Container */
        #app { display: flex; flex-direction: column; height: 100%; width: 100%; }

        /* Header Styles */
        #header { padding: 8px 10px; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; gap: 10px; z-index: 500; position: relative; }
        #location-info { background-color: rgba(40, 40, 40, 0.7); padding: 5px 10px; border-radius: 5px; text-align: center; font-size: 12px; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .status-pill { display: inline-block; padding: 3px 8px; border-radius: 12px; margin-left: 5px; font-size: 11px; font-weight: bold; }
        .status-good { background-color: #34a853; color: white; } .status-bad { background-color: #ea4335; color: white; } .status-wait { background-color: #fbbc05; color: black; }

        /* Leaflet Map Container */
        #map, #chart-map {
            flex-grow: 1; background-color: #222; width: 100%;
            z-index: 1; cursor: grab;
            transition: background-color 0.3s ease; /* Smooth transition for bg toggle */
         }
        #map:active, #chart-map:active { cursor: grabbing; }
        /* Style when map background tiles are hidden */
        #map.map-background-hidden,
        #chart-map.map-background-hidden {
            background-color: #333; /* Dark grey background when tiles off */
        }

        /* Selected Cone Indicator */
        .selected-cone-indicator { position: absolute; top: 55px; left: 10px; padding: 5px 10px; background-color: rgba(251, 188, 5, 0.8); color: black; border-radius: 15px; font-weight: bold; font-size: 12px; display: none; z-index: 600; }

        /* Controls Area */
        #controls { background-color: rgba(0, 0, 0, 0.7); padding: 10px; display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; z-index: 500; position: relative; }
        .control-row { display: flex; justify-content: space-between; gap: 10px; }

        /* Button Styles */
        button { padding: 10px; border: none; border-radius: 5px; font-weight: bold; font-size: 14px; cursor: pointer; text-align: center; flex-grow: 1; flex-basis: 0; white-space: nowrap; -webkit-tap-highlight-color: transparent; }
        button.primary { background-color: #4285f4; color: white; } button.active { background-color: #34a853; color: white; } button.danger { background-color: #ea4335; color: white; } button.warning { background-color: #fbbc05; color: black; } button:disabled { background-color: #777; color: #ccc; cursor: not-allowed; }

        /* Slider Styles */
        .slider-container { display: flex; flex-direction: column; padding: 8px 10px; background-color: rgba(40, 40, 40, 0.7); border-radius: 5px; gap: 5px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; }
        input[type="range"] { width: 100%; cursor: pointer; }

        /* Modal Styles */
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center; padding: 20px; }
        .modal-content { background-color: #282828; padding: 20px; border-radius: 10px; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 15px; }
        .modal-title { font-size: 18px; font-weight: bold; text-align: center; }
        .modal-input { width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #444; background-color: #333; color: white; font-size: 16px; }
        .modal-actions { display: flex; justify-content: space-between; gap: 10px; }

        /* Main Menu Styles */
        #main-menu-screen { justify-content: center; align-items: center; }
        #main-menu { display: flex; flex-direction: column; padding: 20px; width: 100%; max-width: 350px; align-items: center; gap: 20px; }
        .menu-title { font-size: 28px; margin-bottom: 20px; text-align: center; }
        .menu-button { width: 100%; padding: 15px; font-size: 18px; }

        /* Saved Charts Screen Styles */
        #charts-container { flex-grow: 1; overflow-y: auto; padding: 10px; }
        #no-charts-message { text-align: center; padding: 20px; color: #aaa; }
        #charts-list { list-style: none; border: 1px solid #444; border-radius: 5px; overflow: hidden; }
        .chart-item { padding: 12px 15px; border-bottom: 1px solid #444; cursor: pointer; font-size: 14px; display: flex; justify-content: space-between; align-items: center; }
        .chart-item:last-child { border-bottom: none; } .chart-item:hover { background-color: #333; }
        .chart-item-name { flex-grow: 1; margin-right: 10px; } .chart-item-details { font-size: 12px; color: #bbb; white-space: nowrap; }
        .chart-item button { flex-grow: 0; padding: 5px 8px; font-size: 12px; margin-left: 10px; }

        /* Chart View Screen Header */
        #chart-name { text-align: center; font-size: 16px; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; margin: 0 10px; }

        /* Back Button */
        .back-button { position: absolute; top: 8px; left: 10px; padding: 8px 12px; background-color: rgba(50, 50, 50, 0.8); border: 1px solid #555; color: white; border-radius: 5px; z-index: 600; font-size: 16px; line-height: 1; cursor: pointer; }

        /* Leaflet Marker Styling */
        .cone-marker-icon { background: none; border: none; text-align: center; line-height: 1; display: flex; justify-content: center; align-items: center; }
        .cone-marker-icon svg { width: 100%; height: 100%; overflow: visible; }
        .cone-base { fill: orange; stroke: black; stroke-width: 0.5; }
        .cone-pointer { fill: red; stroke: black; stroke-width: 0.5; }
        .start-cone-base { fill: limegreen; stroke: black; stroke-width: 0.5; }
        .cone-marker-icon.selected svg .cone-base, .cone-marker-icon.selected svg .start-cone-base { stroke: yellow; stroke-width: 2; }
        .cone-marker-icon.selected svg .cone-pointer { stroke: yellow; stroke-width: 1; }
        .leaflet-marker-draggable { cursor: grab; } .leaflet-marker-dragging { cursor: grabbing; }
        .leaflet-control-attribution { font-size: 10px !important; background: rgba(255,255,255,0.7) !important; color: #333 !important; padding: 0 5px !important; }
        .leaflet-touch .leaflet-control-layers, .leaflet-touch .leaflet-bar { border: 2px solid rgba(0,0,0,0.2); }
    </style>
</head>
<body class="noselect">

    <!-- Main Menu Screen -->
    <div id="main-menu-screen" class="screen active">
        <div id="main-menu">
            <h1 class="menu-title">Autocross Mapper</h1>
            <button class="menu-button primary" id="new-chart-button">Create New Chart</button>
            <button class="menu-button" id="saved-charts-button">View Saved Charts</button>
            <button class="menu-button warning" id="import-chart-button-main">Import Chart</button>
        </div>
    </div>

    <!-- Mapping Screen -->
    <div id="mapping-screen" class="screen">
        <div id="app">
            <button id="back-to-main-button" class="back-button">←</button>
            <div id="selected-cone-indicator" class="selected-cone-indicator">Pointer Cone Selected</div>
            <div id="header">
                <div id="location-info">Waiting for GPS...<span id="accuracy-status" class="status-pill status-wait">WAIT</span></div>
                <button id="save-button" class="primary" disabled>Save</button>
            </div>
            <div id="map"></div> <!-- Map container -->
            <div id="controls">
                <div class="slider-container">
                    <div class="slider-label"><span>GPS Accuracy Threshold:</span><span id="accuracy-threshold-value">10.0 m</span></div>
                    <input type="range" id="accuracy-threshold-slider" min="1" max="50" value="10" step="0.5">
                </div>
                <div class="control-row">
                    <button id="btn-pointer-cone" class="active">Pointer Cone</button>
                    <button id="btn-single-cone">Single Cone</button>
                </div>
                <div class="control-row">
                    <button id="btn-tag-cone" class="primary" disabled>Tag Cone</button>
                    <button id="btn-delete-last-cone" class="danger">Delete Last</button>
                </div>
                 <div class="slider-container">
                     <div class="slider-label"><span>Rotate World (Markers):</span><span id="rotation-value">0°</span></div>
                     <input type="range" id="world-rotation-slider" min="-180" max="180" value="0" step="1">
                 </div>
                <div id="pointer-rotation-container" class="slider-container" style="display:none;">
                    <div class="slider-label"><span>Selected Pointer Rotation:</span><span id="pointer-rotation-value">0°</span></div>
                    <input type="range" id="pointer-rotation-slider" min="-180" max="180" value="0" step="1">
                </div>
                <div class="control-row">
                    <button id="btn-auto-rotate" class="primary">Auto-Rotate Map</button>
                </div>
                <!-- Map Toggle Button -->
                <div class="control-row">
                    <button id="toggle-map-bg-mapping" class="warning">Show Map</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Saved Charts Screen -->
    <div id="saved-charts-screen" class="screen">
         <div id="app">
            <button id="back-from-charts-button" class="back-button">←</button>
            <div id="header"><h2 style="text-align: center; flex-grow: 1;">Saved Charts</h2></div>
            <div id="charts-container">
                <div id="no-charts-message">No saved charts yet. Create one or import a chart.</div>
                <ul id="charts-list"></ul>
            </div>
            <div id="controls">
                <div class="control-row">
                    <button id="import-chart-button-saved" class="primary">Import Chart</button>
                    <button id="delete-all-charts-button" class="danger">Delete All Charts</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart View Screen -->
    <div id="chart-view-screen" class="screen">
        <div id="app">
            <button id="back-from-chart-view-button" class="back-button">←</button>
            <div id="header">
                <h2 id="chart-name">Chart View</h2>
                <button id="export-current-chart-button" class="warning">Export</button>
            </div>
            <div id="chart-map"></div> <!-- Chart map container -->
            <div id="controls">
                <!-- Map Toggle Button -->
                <div class="control-row">
                    <button id="toggle-map-bg-chart" class="warning">Show Map</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Chart Modal -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Save Chart</div>
            <input type="text" id="chart-name-input" class="modal-input" placeholder="Enter chart name">
            <div class="modal-actions">
                <button id="cancel-save" class="danger">Cancel</button>
                <button id="confirm-save" class="primary">Save</button>
            </div>
        </div>
    </div>

    <!-- File Input (Hidden) -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <script>
        // ==== Enums and Constants ====
        const ConeType = { STARTING: 'starting', POINTER: 'pointer', SINGLE: 'single' };
        const INITIAL_MAP_ZOOM = 19; const INITIAL_CHART_ZOOM = 18;
        const ICON_SIZE_PX = 24; const POINTER_LENGTH = 10; const POINTER_WIDTH = 8;

        // ==== App State ====
        const state = {
            currentScreen: 'main-menu', selectedConeType: ConeType.POINTER,
            currentLocation: null, cones: [], selectedConeIndex: null,
            gpsAccuracyThreshold: 10.0, isGPSReady: false,
            savedCharts: [], currentViewingChart: null, pointerConeRotation: 0,
            worldRotation: 0, rotationCenter: null,
            deviceHeading: 0, autoRotateEnabled: false,
            mapInstance: null, chartMapInstance: null, userLocationMarker: null,
            coneMarkersLayer: null, chartMarkersLayer: null,
        };

        // ==== DOM Elements ====
        // Navigation & Screens
        const screens = { mainMenu: document.getElementById('main-menu-screen'), mapping: document.getElementById('mapping-screen'), savedCharts: document.getElementById('saved-charts-screen'), chartView: document.getElementById('chart-view-screen'), };
        const newChartButton = document.getElementById('new-chart-button'); const savedChartsButton = document.getElementById('saved-charts-button'); const backToMainButton = document.getElementById('back-to-main-button'); const backFromChartsButton = document.getElementById('back-from-charts-button'); const backFromChartViewButton = document.getElementById('back-from-chart-view-button');
        // Mapping Screen Elements
        const locationInfo = document.getElementById('location-info'); const accuracyStatus = document.getElementById('accuracy-status'); const saveButton = document.getElementById('save-button'); const mapContainer = document.getElementById('map'); const selectedConeIndicator = document.getElementById('selected-cone-indicator'); const accuracyThresholdSlider = document.getElementById('accuracy-threshold-slider'); const accuracyThresholdValue = document.getElementById('accuracy-threshold-value'); const btnPointerCone = document.getElementById('btn-pointer-cone'); const btnSingleCone = document.getElementById('btn-single-cone'); const btnTagCone = document.getElementById('btn-tag-cone'); const btnDeleteLastCone = document.getElementById('btn-delete-last-cone'); const pointerRotationContainer = document.getElementById('pointer-rotation-container'); const pointerRotationSlider = document.getElementById('pointer-rotation-slider'); const pointerRotationValue = document.getElementById('pointer-rotation-value');
        const worldRotationSlider = document.getElementById('world-rotation-slider'); const rotationValue = document.getElementById('rotation-value');
        const btnAutoRotate = document.getElementById('btn-auto-rotate');
        const toggleMapBgMappingButton = document.getElementById('toggle-map-bg-mapping');
        // Chart View Screen Elements
        const chartMapContainer = document.getElementById('chart-map'); const chartName = document.getElementById('chart-name'); const exportCurrentChartButton = document.getElementById('export-current-chart-button');
        const toggleMapBgChartButton = document.getElementById('toggle-map-bg-chart');
        // Saved Charts Screen Elements
        const chartsContainer = document.getElementById('charts-container'); const noChartsMessage = document.getElementById('no-charts-message'); const chartsList = document.getElementById('charts-list'); const importChartButtonMain = document.getElementById('import-chart-button-main'); const importChartButtonSaved = document.getElementById('import-chart-button-saved'); const deleteAllChartsButton = document.getElementById('delete-all-charts-button');
        // Chart View Screen Elements removed (already defined above)
        // Modal Elements
        const modal = document.getElementById('modal'); const chartNameInput = document.getElementById('chart-name-input'); const cancelSaveButton = document.getElementById('cancel-save'); const confirmSaveButton = document.getElementById('confirm-save');
        // Hidden File Input
        const importFileInput = document.getElementById('import-file-input');

        // ==== Core Classes ====
        class Cone { constructor(latitude, longitude, type = ConeType.SINGLE, rotation = 0) { this.latitude = latitude; this.longitude = longitude; this.type = type; this.rotation = rotation; this.id = 'cone_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); this.leafletMarker = null; } }

        // ==== Leaflet Icons (with outward pointer) ====
        const createSvgIcon = (type) => { const svgNs = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNs, "svg"); svg.setAttribute("viewBox", "-12 -12 24 24"); svg.setAttribute("width", ICON_SIZE_PX); svg.setAttribute("height", ICON_SIZE_PX); svg.style.overflow = "visible"; const baseRadius = 6; const circle = document.createElementNS(svgNs, "circle"); circle.setAttribute("cx", "0"); circle.setAttribute("cy", "0"); circle.setAttribute("r", baseRadius); circle.classList.add(type === ConeType.STARTING ? 'start-cone-base' : 'cone-base'); svg.appendChild(circle); if (type === ConeType.POINTER) { const triangle = document.createElementNS(svgNs, "polygon"); const tipX = baseRadius + 1; const baseMidX = tipX + POINTER_LENGTH; const halfWidth = POINTER_WIDTH / 2; triangle.setAttribute("points", `${tipX},0 ${baseMidX},-${halfWidth} ${baseMidX},${halfWidth}`); triangle.classList.add('cone-pointer'); svg.appendChild(triangle); } const serializer = new XMLSerializer(); return serializer.serializeToString(svg); };
        const singleConeIcon = L.divIcon({ html: createSvgIcon(ConeType.SINGLE), className: 'cone-marker-icon', iconSize: [ICON_SIZE_PX, ICON_SIZE_PX], iconAnchor: [ICON_SIZE_PX / 2, ICON_SIZE_PX / 2] });
        const pointerConeIcon = L.divIcon({ html: createSvgIcon(ConeType.POINTER), className: 'cone-marker-icon pointer-cone-icon', iconSize: [ICON_SIZE_PX, ICON_SIZE_PX], iconAnchor: [ICON_SIZE_PX / 2, ICON_SIZE_PX / 2] });
        const startConeIcon = L.divIcon({ html: createSvgIcon(ConeType.STARTING), className: 'cone-marker-icon', iconSize: [ICON_SIZE_PX, ICON_SIZE_PX], iconAnchor: [ICON_SIZE_PX / 2, ICON_SIZE_PX / 2] });

        // ==== Coordinate Rotation Helper ====
        function rotateLatLngAroundCenter(map, pointLatLng, centerLatLng, angleDegrees) { if (!map || !pointLatLng || !centerLatLng || angleDegrees === 0) return pointLatLng; const currentZoom = map.getZoom(); const centerPoint = map.project(centerLatLng, currentZoom); const point = map.project(pointLatLng, currentZoom); const dx = point.x - centerPoint.x; const dy = point.y - centerPoint.y; const angleRad = angleDegrees * Math.PI / 180.0; const cosA = Math.cos(angleRad); const sinA = Math.sin(angleRad); const rotatedDx = dx * cosA - dy * sinA; const rotatedDy = dx * sinA + dy * cosA; const newPoint = L.point(centerPoint.x + rotatedDx, centerPoint.y + rotatedDy); return map.unproject(newPoint, currentZoom); }

        // ==== Leaflet Map Initialization ====
        function initializeMapView(centerCoords = [0, 0], zoom = INITIAL_MAP_ZOOM) {
            if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; }
            if (!mapContainer) { console.error("Map container div not found!"); return; }
            console.log("Initializing main map view at", centerCoords, "zoom", zoom);
            state.mapInstance = L.map(mapContainer, { center: centerCoords, zoom: zoom, zoomControl: true, attributionControl: true });

            if (!state.coneMarkersLayer) state.coneMarkersLayer = L.layerGroup(); else state.coneMarkersLayer.clearLayers();
            state.coneMarkersLayer.addTo(state.mapInstance);
            state.mapInstance.on('click', deselectCone);
            L.control.scale({ imperial: false }).addTo(state.mapInstance);

            state.cones.forEach((cone, index) => createOrUpdateConeMarker(cone, index));
        }
        function initializeChartView(centerCoords, zoom = INITIAL_CHART_ZOOM, cones = []) {
             if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; }
             if (state.chartMapInstance) { state.chartMapInstance.remove(); state.chartMapInstance = null; }
             if (!chartMapContainer) { console.error("Chart map container div not found!"); return; }
             console.log("Initializing chart map view.");
             state.chartMapInstance = L.map(chartMapContainer).setView(centerCoords, zoom);

             if (!state.chartMarkersLayer) state.chartMarkersLayer = L.layerGroup(); else state.chartMarkersLayer.clearLayers();
             state.chartMarkersLayer.addTo(state.chartMapInstance);
             L.control.scale({ imperial: false }).addTo(state.chartMapInstance);
             cones.forEach(coneData => { const cone = new Cone(coneData.latitude, coneData.longitude, coneData.type, coneData.rotation); createOrUpdateConeMarker(cone, -1, false, state.chartMarkersLayer); });

             fitMapToLayer(state.chartMarkersLayer, state.chartMapInstance, centerCoords, zoom);
         }
        function fitMapToLayer(layerGroup, mapInstance, fallbackCenter, fallbackZoom) { if (!layerGroup || !mapInstance) return; const bounds = layerGroup.getBounds(); if (bounds && bounds.isValid()) mapInstance.fitBounds(bounds.pad(0.1)); else mapInstance.setView(fallbackCenter, fallbackZoom); }

        // ==== Cone Management Functions (with World Rotation) ====
        function createOrUpdateConeMarker(cone, index, draggable = true, layerGroup = null) { /* ... same as before ... */
            if (!layerGroup) layerGroup = (state.currentScreen === 'mapping') ? state.coneMarkersLayer : state.chartMarkersLayer; if (!layerGroup || !cone) { console.error("Layer/cone missing for marker."); return; } const map = (state.currentScreen === 'mapping') ? state.mapInstance : state.chartMapInstance; if (!map) { console.error("Map instance missing for marker."); return; } if (cone.leafletMarker) { try { layerGroup.removeLayer(cone.leafletMarker); } catch(e){} cone.leafletMarker = null; }
            let originalLatLng = L.latLng(cone.latitude, cone.longitude); let displayLatLng = originalLatLng; let displayRotation = cone.rotation || 0;
            if (state.currentScreen === 'mapping' && state.rotationCenter && state.worldRotation !== 0 && index >= 0) { const centerLatLng = L.latLng(state.rotationCenter.lat, state.rotationCenter.lng); displayLatLng = rotateLatLngAroundCenter(map, originalLatLng, centerLatLng, state.worldRotation); if (cone.type === ConeType.POINTER) displayRotation = (cone.rotation || 0) + state.worldRotation; }
            let icon; if (cone.type === ConeType.STARTING) icon = startConeIcon; else if (cone.type === ConeType.POINTER) icon = pointerConeIcon; else icon = singleConeIcon;
            const markerOptions = { icon: icon, rotationOrigin: 'center center', rotationAngle: displayRotation, draggable: draggable, bubblingMouseEvents: false }; const marker = L.marker(displayLatLng, markerOptions); cone.leafletMarker = marker;
            if (index >= 0) { marker.on('click', (e) => { const currentIdx = state.cones.findIndex(c => c.id === cone.id); if (currentIdx !== -1) selectCone(currentIdx); }); if (draggable) { marker.on('dragend', (e) => { const draggedMarker = e.target; const finalLatLng = draggedMarker.getLatLng(); const coneIndex = state.cones.findIndex(c => c.leafletMarker === draggedMarker); if (coneIndex !== -1) { let originalLatLng = finalLatLng; if (state.rotationCenter && state.worldRotation !== 0) { const centerLatLng = L.latLng(state.rotationCenter.lat, state.rotationCenter.lng); originalLatLng = rotateLatLngAroundCenter(map, finalLatLng, centerLatLng, -state.worldRotation); } state.cones[coneIndex].latitude = originalLatLng.lat; state.cones[coneIndex].longitude = originalLatLng.lng; createOrUpdateConeMarker(state.cones[coneIndex], coneIndex, true); console.log(`Cone ${coneIndex} dragend. Stored original @ ${originalLatLng.lat.toFixed(6)}, ${originalLatLng.lng.toFixed(6)}`); updateSaveButtonState(); } }); } }
            marker.addTo(layerGroup); if (index >= 0 && index === state.selectedConeIndex && marker._icon) L.DomUtil.addClass(marker._icon, 'selected');
        }
        function tagCone() { /* ... same as before ... */ if (!state.currentLocation || !state.isGPSReady || !state.mapInstance || !state.coneMarkersLayer) { alert("GPS/Map not ready."); return; } let coneType = (state.cones.length < 2) ? ConeType.STARTING : state.selectedConeType; let coneRotation = (coneType === ConeType.POINTER) ? state.pointerConeRotation : 0; const newCone = new Cone(state.currentLocation.latitude, state.currentLocation.longitude, coneType, coneRotation); if (state.cones.length === 0) { state.rotationCenter = { lat: newCone.latitude, lng: newCone.longitude }; state.worldRotation = 0; worldRotationSlider.value = 0; rotationValue.textContent = `0°`; console.log("Rotation center set:", state.rotationCenter); } state.cones.push(newCone); const newIndex = state.cones.length - 1; createOrUpdateConeMarker(newCone, newIndex, true); updateSaveButtonState(); if (newCone.type === ConeType.POINTER) { selectCone(newIndex); } else { deselectCone(); } }
        function deleteLastCone() { /* ... same as before ... */ if (state.cones.length > 0 && state.coneMarkersLayer) { const deletedConeIndex = state.cones.length - 1; const deletedCone = state.cones.pop(); if (deletedCone.leafletMarker) { try {state.coneMarkersLayer.removeLayer(deletedCone.leafletMarker);} catch(e){} } if (state.selectedConeIndex === deletedConeIndex) deselectCone(); updateSaveButtonState(); } }
        function selectCone(index) { /* ... same as before ... */ if (index === null || index < 0 || index >= state.cones.length || state.currentScreen !== 'mapping') { deselectCone(); return; } const coneToSelect = state.cones[index]; if (!coneToSelect) return; if (state.selectedConeIndex !== null && state.selectedConeIndex < state.cones.length) { const prevCone = state.cones[state.selectedConeIndex]; if (prevCone?.leafletMarker?._icon) L.DomUtil.removeClass(prevCone.leafletMarker._icon, 'selected'); } state.selectedConeIndex = index; if (coneToSelect.leafletMarker?._icon) L.DomUtil.addClass(coneToSelect.leafletMarker._icon, 'selected'); if (coneToSelect.type === ConeType.POINTER) { state.pointerConeRotation = coneToSelect.rotation; pointerRotationSlider.value = coneToSelect.rotation; pointerRotationValue.textContent = `${Math.round(coneToSelect.rotation)}°`; pointerRotationContainer.style.display = 'flex'; selectedConeIndicator.style.display = 'block'; } else { pointerRotationContainer.style.display = 'none'; selectedConeIndicator.style.display = 'none'; } }
        function deselectCone() { /* ... same as before ... */ if (state.selectedConeIndex !== null && state.selectedConeIndex < state.cones.length) { const prevCone = state.cones[state.selectedConeIndex]; if (prevCone?.leafletMarker?._icon) L.DomUtil.removeClass(prevCone.leafletMarker._icon, 'selected'); } state.selectedConeIndex = null; pointerRotationContainer.style.display = 'none'; selectedConeIndicator.style.display = 'none'; }
        function updateSelectedConeRotation(rotation) { /* ... same as before ... */ if (state.selectedConeIndex !== null && state.cones[state.selectedConeIndex]) { const cone = state.cones[state.selectedConeIndex]; if (cone.type === ConeType.POINTER) { cone.rotation = rotation; let displayRotation = rotation + state.worldRotation; if (cone.leafletMarker && typeof cone.leafletMarker.setRotationAngle === 'function') { cone.leafletMarker.setRotationAngle(displayRotation); } updateSaveButtonState(); } } }
        function updateSaveButtonState() { saveButton.disabled = state.cones.length === 0; }

        // ==== Geolocation and Device Orientation Functions ====
        // ... initGeolocation, stopGeolocation, handleLocationUpdate, handleLocationError, updateLocationStatus ...
        // ... remain the same ...
        let watchId = null; let isFirstLocationUpdate = true;
        let deviceOrientationId = null;
        function initGeolocation() { if (!('geolocation' in navigator)) { updateLocationStatus("BAD", "NO GPS", "Geolocation not supported"); btnTagCone.disabled = true; return; } if (watchId !== null) navigator.geolocation.clearWatch(watchId); updateLocationStatus("WAIT", "Requesting GPS..."); if (state.userLocationMarker && state.mapInstance) { try { state.mapInstance.removeLayer(state.userLocationMarker); } catch(e){} state.userLocationMarker = null; } state.currentLocation = null; state.isGPSReady = false; btnTagCone.disabled = true; isFirstLocationUpdate = true; navigator.geolocation.getCurrentPosition(handleLocationUpdate, handleLocationError, { enableHighAccuracy: true, maximumAge: 60000, timeout: 10000 }); watchId = navigator.geolocation.watchPosition(handleLocationUpdate, handleLocationError, { enableHighAccuracy: true, maximumAge: 2000, timeout: 5000 }); 
            // Initialize device orientation if we're on the mapping screen
            if (state.currentScreen === 'mapping') {
                initDeviceOrientation();
            }
        }
        function stopGeolocation() { if (watchId !== null && navigator.geolocation) { navigator.geolocation.clearWatch(watchId); watchId = null; updateLocationStatus("BAD", "OFF", "GPS Disabled"); if (state.userLocationMarker && state.mapInstance) { try { state.mapInstance.removeLayer(state.userLocationMarker); } catch(e){} state.userLocationMarker = null; } state.isGPSReady = false; btnTagCone.disabled = true; } 
            // Stop device orientation when we stop geolocation
            stopDeviceOrientation();
        }
        function handleLocationUpdate(position) { const lat = position.coords.latitude, lon = position.coords.longitude, accuracy = position.coords.accuracy; state.currentLocation = { latitude: lat, longitude: lon, accuracy: accuracy }; state.isGPSReady = accuracy <= state.gpsAccuracyThreshold; const statusText = `Lat:${lat.toFixed(6)}, Lon:${lon.toFixed(6)} | Acc:${accuracy.toFixed(1)}m`; updateLocationStatus(state.isGPSReady ? "GOOD" : "BAD", state.isGPSReady ? "OK" : "ACC POOR", statusText); btnTagCone.disabled = !state.isGPSReady; if (state.mapInstance && state.currentScreen === 'mapping') { const currentLatLng = L.latLng(lat, lon); if (isFirstLocationUpdate && state.isGPSReady) { console.log("First good GPS fix, centering map."); state.mapInstance.setView(currentLatLng, state.mapInstance.getZoom() || INITIAL_MAP_ZOOM); isFirstLocationUpdate = false; } if (!state.userLocationMarker) { state.userLocationMarker = L.layerGroup([ L.circle(currentLatLng, { radius: accuracy, color: 'blue', fillColor: '#30f', fillOpacity: 0.10, weight: 1, interactive: false }), L.circleMarker(currentLatLng, { radius: 4, color: 'white', fillColor: 'blue', fillOpacity: 1, weight: 1, interactive: false}) ]).addTo(state.mapInstance); } else { const layers = state.userLocationMarker.getLayers(); if (layers.length === 2) { layers[0].setLatLng(currentLatLng).setRadius(accuracy); layers[1].setLatLng(currentLatLng); } } } else if (!state.mapInstance && state.currentScreen === 'mapping' && state.isGPSReady) { initializeMapView([lat, lon]); } }
        function handleLocationError(error) { console.error('Geolocation Error:', error.code, error.message); let msg='GPS Error', lbl="ERROR"; switch(error.code) { case 1: msg="GPS Permission Denied"; lbl="DENIED"; break; case 2: msg="GPS Position Unavailable"; lbl="UNAVAIL"; break; case 3: msg="GPS Timeout"; lbl="TIMEOUT"; break; } updateLocationStatus("BAD", lbl, msg); state.currentLocation = null; state.isGPSReady = false; btnTagCone.disabled = true; if (state.userLocationMarker && state.mapInstance) { try { state.mapInstance.removeLayer(state.userLocationMarker); } catch(e){} state.userLocationMarker = null; } }
        function updateLocationStatus(type, label, info) { locationInfo.innerHTML = `${info} <span id="accuracy-status" class="status-pill status-${type.toLowerCase()}">${label}</span>`; }
        
        // ==== Device Orientation Functions ====
        function initDeviceOrientation() {
            if (deviceOrientationId) {
                stopDeviceOrientation();
            }
            
            // Check if DeviceOrientationEvent is available
            if (window.DeviceOrientationEvent) {
                console.log('Device orientation is supported');
                
                // Some browsers (like iOS) require permission for device orientation
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+ requires permission
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                deviceOrientationId = window.addEventListener('deviceorientation', handleDeviceOrientation);
                                console.log('Device orientation permission granted');
                            } else {
                                console.warn('Device orientation permission denied');
                            }
                        })
                        .catch(console.error);
                } else {
                    // Non-iOS or older iOS versions
                    deviceOrientationId = window.addEventListener('deviceorientation', handleDeviceOrientation);
                }
            } else {
                console.warn('Device orientation not supported');
            }
        }
        
        function stopDeviceOrientation() {
            if (deviceOrientationId && window.DeviceOrientationEvent) {
                window.removeEventListener('deviceorientation', handleDeviceOrientation);
                deviceOrientationId = null;
                console.log('Device orientation listener removed');
            }
        }
        
        function handleDeviceOrientation(event) {
            // Get the device heading (compass direction)
            // alpha is the compass direction the device is facing in degrees
            if (event.webkitCompassHeading) {
                // iOS devices use webkitCompassHeading (measured clockwise from North)
                state.deviceHeading = event.webkitCompassHeading;
            } else if (event.alpha !== null) {
                // Android devices use alpha (measured counter-clockwise from West)
                // Convert to clockwise from North
                state.deviceHeading = (360 - event.alpha) % 360;
            }
            
            // Update the world rotation if auto-rotate is enabled
            if (state.autoRotateEnabled && state.currentScreen === 'mapping') {
                // Convert device heading to map rotation
                // We negate the value because we want to rotate the map in the opposite direction
                // to give the impression that we're facing "up" on the map
                const mapRotation = -state.deviceHeading;
                
                // Only update if there's a significant change (to prevent constant small updates)
                if (Math.abs(mapRotation - state.worldRotation) > 3) {
                    state.worldRotation = mapRotation;
                    
                    // Update the rotation slider to match
                    if (worldRotationSlider) {
                        worldRotationSlider.value = mapRotation;
                        rotationValue.textContent = `${Math.round(mapRotation)}°`;
                    }
                    
                    // Apply rotation to all cones
                    applyWorldRotation();
                }
            }
        }
        
        function applyWorldRotation() {
            if (!state.rotationCenter || !state.mapInstance) return;
            
            state.cones.forEach(cone => {
                if (cone.leafletMarker) {
                    let displayLatLng = L.latLng(cone.latitude, cone.longitude);
                    let displayRotation = cone.rotation || 0;
                    const centerLatLng = L.latLng(state.rotationCenter.lat, state.rotationCenter.lng);
                    displayLatLng = rotateLatLngAroundCenter(state.mapInstance, displayLatLng, centerLatLng, state.worldRotation);
                    
                    if (cone.type === ConeType.POINTER) {
                        displayRotation = (cone.rotation || 0) + state.worldRotation;
                    }
                    
                    cone.leafletMarker.setLatLng(displayLatLng);
                    if (typeof cone.leafletMarker.setRotationAngle === 'function') {
                        cone.leafletMarker.setRotationAngle(displayRotation);
                    }
                }
            });
        }
        
        function toggleAutoRotate() {
            state.autoRotateEnabled = !state.autoRotateEnabled;
            
            if (state.autoRotateEnabled) {
                btnAutoRotate.textContent = 'Disable Auto-Rotate';
                btnAutoRotate.classList.remove('primary');
                btnAutoRotate.classList.add('active');
                
                // Make sure device orientation is initialized
                initDeviceOrientation();
            } else {
                btnAutoRotate.textContent = 'Auto-Rotate Map';
                btnAutoRotate.classList.remove('active');
                btnAutoRotate.classList.add('primary');
            }
        }
        
        // ==== Map Background Toggle Function ====
        function toggleMapBackground() {
            let mapInstance = null, tileLayer = null, button = null, container = null;
            if (state.currentScreen === 'mapping' && state.mapInstance && state.mapTileLayer) { 
                mapInstance = state.mapInstance; 
                tileLayer = state.mapTileLayer; 
                button = toggleMapBgMappingButton; 
                container = mapContainer; 
            }
            else if (state.currentScreen === 'chartView' && state.chartMapInstance && state.chartTileLayer) { 
                mapInstance = state.chartMapInstance; 
                tileLayer = state.chartTileLayer; 
                button = toggleMapBgChartButton; 
                container = chartMapContainer; 
            }
            else { 
                console.warn("Cannot toggle map background: No active/valid map."); 
                return; 
            }

            if (mapInstance.hasLayer(tileLayer)) { // Hide
                mapInstance.removeLayer(tileLayer); 
                button.textContent = "Show Map"; 
                container.classList.add('map-background-hidden'); 
                console.log("Map background hidden.");
            } else { // Show
                tileLayer.addTo(mapInstance); 
                button.textContent = "Hide Map"; 
                container.classList.remove('map-background-hidden'); 
                console.log("Map background shown.");
            }
        }

        // ==== Storage Functions ====
        // ... saveCurrentChart, loadSavedCharts, deleteChart, deleteAllCharts, exportChart, importChartFromFile ...
        // ... remain the same ...
        const STORAGE_KEY = 'autocrossCharts_v5';
        function saveCurrentChart(name) { if (state.cones.length === 0) { alert('No cones to save!'); return false; } const serializableCones = state.cones.map(c => ({ latitude: c.latitude, longitude: c.longitude, type: c.type, rotation: c.rotation, id: c.id })); const chartData = { name: name, coneData: serializableCones, createdAt: new Date().toISOString() }; loadSavedCharts(); const existingIndex = state.savedCharts.findIndex(c => c.name === name); if (existingIndex !== -1) state.savedCharts.splice(existingIndex, 1); state.savedCharts.push(chartData); try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts)); alert(`Chart "${name}" saved.`); return true; } catch (e) { console.error("Save Error:", e); alert("Error saving chart."); loadSavedCharts(); return false; } }
        function loadSavedCharts() { try { const stored = localStorage.getItem(STORAGE_KEY); state.savedCharts = stored ? JSON.parse(stored) : []; if (!Array.isArray(state.savedCharts)) { state.savedCharts = []; localStorage.removeItem(STORAGE_KEY); } } catch (e) { console.error("Load Error:", e); state.savedCharts = []; } return state.savedCharts; }
        function deleteChart(name) { if (!confirm(`Delete chart "${name}"?`)) return; loadSavedCharts(); state.savedCharts = state.savedCharts.filter(c => c.name !== name); try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts)); updateChartsList(); } catch (e) { console.error("Delete Error:", e); alert("Error deleting."); loadSavedCharts(); } }
        function deleteAllCharts() { if (state.savedCharts.length === 0 || !confirm("Delete ALL charts?")) return; state.savedCharts = []; try { localStorage.removeItem(STORAGE_KEY); updateChartsList(); } catch (e) { console.error("Delete All Error:", e); alert("Error clearing charts."); loadSavedCharts(); } }
        function exportChart(chart) { if (!chart) return; try { const exportData = { name: chart.name, coneData: chart.coneData.map(c => ({ latitude: c.latitude, longitude: c.longitude, type: c.type, rotation: c.rotation, id: c.id })), createdAt: chart.createdAt }; const json = JSON.stringify(exportData, null, 2); const blob = new Blob([json], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); const filename = chart.name.replace(/[^a-z0-9_ -]/gi, '_').replace(/\s+/g, '_'); a.href = url; a.download = `${filename || 'autocross_chart'}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 100); } catch (e) { console.error("Export Error:", e); alert("Could not export."); } }
        function importChartFromFile(file) { const reader = new FileReader(); reader.onload = (e) => { try { const imported = JSON.parse(e.target.result); if (typeof imported !== 'object' || !imported.name || !Array.isArray(imported.coneData)) throw new Error("Invalid format."); for(const c of imported.coneData) { if (typeof c.latitude !== 'number' || typeof c.longitude !== 'number' || typeof c.type !== 'string') throw new Error("Invalid cone data."); c.rotation = c.rotation || 0; } loadSavedCharts(); const existing = state.savedCharts.find(c => c.name === imported.name); if (existing && !confirm(`Overwrite chart "${imported.name}"?`)) { importFileInput.value = ''; return; } state.savedCharts = state.savedCharts.filter(c => c.name !== imported.name); const newChart = { name: imported.name, coneData: imported.coneData, createdAt: imported.createdAt || new Date().toISOString() }; state.savedCharts.push(newChart); localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts)); alert(`Chart "${newChart.name}" imported.`); if(state.currentScreen === 'savedCharts') updateChartsList(); } catch (error) { console.error("Import Error:", error); alert('Error importing: ' + error.message); } finally { importFileInput.value = ''; } }; reader.onerror = () => { alert('Error reading file.'); importFileInput.value = ''; }; reader.readAsText(file); }
        function triggerImport() { importFileInput.click(); }
        function updateChartsList() { /* ... same ... */ loadSavedCharts(); if (state.savedCharts.length === 0) { noChartsMessage.style.display = 'block'; chartsList.style.display = 'none'; chartsList.innerHTML = ''; } else { noChartsMessage.style.display = 'none'; chartsList.style.display = 'block'; chartsList.innerHTML = ''; const sorted = [...state.savedCharts].sort((a, b) => (b.createdAt || 0).localeCompare(a.createdAt || 0)); sorted.forEach(chart => { const li = document.createElement('li'); li.className = 'chart-item'; const nameSpan = document.createElement('span'); nameSpan.className = 'chart-item-name'; nameSpan.textContent = chart.name; const detailsSpan = document.createElement('span'); detailsSpan.className = 'chart-item-details'; let dateStr = 'Unknown date'; if (chart.createdAt) try { dateStr = new Date(chart.createdAt).toLocaleDateString(); } catch (e) {} const coneCount = Array.isArray(chart.coneData) ? chart.coneData.length : 0; detailsSpan.textContent = `${coneCount} cones (${dateStr})`; const deleteBtn = document.createElement('button'); deleteBtn.className = 'danger'; deleteBtn.textContent = 'Del'; deleteBtn.onclick = (ev) => { ev.stopPropagation(); deleteChart(chart.name); }; li.appendChild(nameSpan); li.appendChild(detailsSpan); li.appendChild(deleteBtn); li.addEventListener('click', () => viewChart(chart)); chartsList.appendChild(li); }); } }
        function viewChart(chart) { /* ... same ... */ if (!chart || !Array.isArray(chart.coneData)) { alert("Invalid chart data."); return; } state.currentViewingChart = chart; chartName.textContent = chart.name; navigateToScreen('chartView'); }
        function generateChartName() { const n=new Date(), d=n.toISOString().split('T')[0], t=n.toTimeString().split(' ')[0].replace(/:/g,'-'); return `Chart_${d}_${t}`; }

        // ==== Navigation ====
        function navigateToScreen(screenId) { /* ... same as before ... */
             console.log(`Navigating to: ${screenId}`); const oldScreen = state.currentScreen; if (oldScreen === screenId) return;
             if (oldScreen === 'mapping') stopGeolocation(); Object.values(screens).forEach(screen => screen.classList.remove('active'));
             if (screens[screenId]) {
                 screens[screenId].classList.add('active'); state.currentScreen = screenId;
                 switch(screenId) {
                     case 'mapping': state.cones = []; state.selectedConeIndex = null; deselectCone(); state.rotationCenter = null; state.worldRotation = 0; worldRotationSlider.value = 0; rotationValue.textContent = `0°`; const startCoords = state.currentLocation ? [state.currentLocation.latitude, state.currentLocation.longitude] : [0, 0]; initializeMapView(startCoords); updateSaveButtonState(); initGeolocation(); 
                        // Reset auto-rotate button state
                        state.autoRotateEnabled = false;
                        btnAutoRotate.textContent = 'Auto-Rotate Map';
                        btnAutoRotate.classList.remove('active');
                        btnAutoRotate.classList.add('primary');
                        break;
                     case 'savedCharts': if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; } if (state.chartMapInstance) { state.chartMapInstance.remove(); state.chartMapInstance = null; } updateChartsList(); break;
                     case 'chartView': if (!state.currentViewingChart) { navigateToScreen('savedCharts'); return; } let centerCoords = [0, 0]; const cones = state.currentViewingChart.coneData; if (cones.length > 0) centerCoords = [cones[0].latitude, cones[0].longitude]; initializeChartView(centerCoords, INITIAL_CHART_ZOOM, cones); break;
                     case 'mainMenu': state.currentViewingChart = null; state.cones = []; if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; } if (state.chartMapInstance) { state.chartMapInstance.remove(); state.chartMapInstance = null; } break;
                 }
                 setTimeout(() => { let mapToUpdate = null; if (screenId === 'mapping' && state.mapInstance) mapToUpdate = state.mapInstance; else if (screenId === 'chartView' && state.chartMapInstance) mapToUpdate = state.chartMapInstance; if (mapToUpdate) { console.log(`Invalidating size for ${screenId} map`); mapToUpdate.invalidateSize({ animate: false }); if (screenId === 'chartView' && state.chartMarkersLayer) fitMapToLayer(state.chartMarkersLayer, mapToUpdate, [0,0], INITIAL_CHART_ZOOM); } }, 150);
             } else { console.error("Screen ID not found:", screenId); }
         }

        // ==== Event Handlers ====
        function setupEventListeners() {
            // -- Button Clicks --
            newChartButton.addEventListener('click', () => navigateToScreen('mapping')); savedChartsButton.addEventListener('click', () => navigateToScreen('savedCharts')); backToMainButton.addEventListener('click', () => navigateToScreen('mainMenu')); backFromChartsButton.addEventListener('click', () => navigateToScreen('mainMenu')); backFromChartViewButton.addEventListener('click', () => navigateToScreen('savedCharts')); btnPointerCone.addEventListener('click', () => { state.selectedConeType = ConeType.POINTER; btnPointerCone.classList.add('active'); btnSingleCone.classList.remove('active'); }); btnSingleCone.addEventListener('click', () => { state.selectedConeType = ConeType.SINGLE; btnSingleCone.classList.add('active'); btnPointerCone.classList.remove('active'); }); btnTagCone.addEventListener('click', tagCone); btnDeleteLastCone.addEventListener('click', deleteLastCone); saveButton.addEventListener('click', () => { if (state.cones.length > 0) { chartNameInput.value = generateChartName(); modal.style.display = 'flex'; } }); deleteAllChartsButton.addEventListener('click', deleteAllCharts); importChartButtonMain.addEventListener('click', triggerImport); importChartButtonSaved.addEventListener('click', triggerImport); importFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) importChartFromFile(e.target.files[0]); }); exportCurrentChartButton.addEventListener('click', () => exportChart(state.currentViewingChart));
            // -- Slider Inputs --
            accuracyThresholdSlider.addEventListener('input', () => { state.gpsAccuracyThreshold = parseFloat(accuracyThresholdSlider.value); accuracyThresholdValue.textContent = `${state.gpsAccuracyThreshold.toFixed(1)} m`; if (state.currentLocation) handleLocationUpdate({ coords: state.currentLocation }); });
            pointerRotationSlider.addEventListener('input', () => { const r = parseFloat(pointerRotationSlider.value); state.pointerConeRotation = r; pointerRotationValue.textContent = `${Math.round(r)}°`; updateSelectedConeRotation(r); });
            worldRotationSlider.addEventListener('input', () => { 
                if (state.currentScreen !== 'mapping' || !state.rotationCenter || !state.mapInstance) return;
                
                // Disable auto-rotate when manually adjusting rotation
                if (state.autoRotateEnabled) {
                    toggleAutoRotate();
                }
                
                state.worldRotation = parseFloat(worldRotationSlider.value); 
                rotationValue.textContent = `${Math.round(state.worldRotation)}°`; 
                applyWorldRotation();
            });
            
            // Auto-rotate toggle button
            btnAutoRotate.addEventListener('click', toggleAutoRotate);
            
            // Register buttons for both maps
            toggleMapBgMappingButton.addEventListener('click', toggleMapBackground);
            toggleMapBgChartButton.addEventListener('click', toggleMapBackground);
            // -- Modal Actions --
            confirmSaveButton.addEventListener('click', () => { const name = chartNameInput.value.trim(); if (!name) { alert('Enter chart name.'); return; } loadSavedCharts(); const existing = state.savedCharts.find(c => c.name === name); if (existing && !confirm(`Overwrite chart "${name}"?`)) return; if (saveCurrentChart(name)) modal.style.display = 'none'; });
            cancelSaveButton.addEventListener('click', () => { modal.style.display = 'none'; });
            // -- Window Resize --
            window.addEventListener('resize', () => { setTimeout(() => { const currentMap = (state.currentScreen === 'mapping') ? state.mapInstance : ((state.currentScreen === 'chartView') ? state.chartMapInstance : null); if (currentMap) currentMap.invalidateSize({animate: false}); }, 250); });
        }

        // ==== Initialization ====
        function initApp() {
             console.log("Autocross Mapper Initializing (vFinal - Hidden BG Default)...");
             setupEventListeners();
             loadSavedCharts();
             navigateToScreen('mainMenu');
             console.log("Autocross Mapper Initialized.");
         }
        window.addEventListener('load', initApp);

    </script>
</body>
</html>