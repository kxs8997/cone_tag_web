<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Autocross Mapper (Leaflet)</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet Rotated Marker Plugin -->
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>

    <style>
        /* Basic Reset & Box Sizing */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: Arial, sans-serif; background-color: #000; color: #fff; }
        .noselect { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }

        /* Screen Management */
        .screen { display: none; width: 100%; height: 100%; overflow: hidden; flex-direction: column; }
        .screen.active { display: flex; }

        /* Main App Container */
        #app { display: flex; flex-direction: column; height: 100%; width: 100%; }

        /* Header Styles */
        #header {
            padding: 8px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            gap: 10px;
            z-index: 500; /* Above map */
            position: relative; /* Needed for z-index */
        }
        #location-info { background-color: rgba(40, 40, 40, 0.7); padding: 5px 10px; border-radius: 5px; text-align: center; font-size: 12px; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .status-pill { display: inline-block; padding: 3px 8px; border-radius: 12px; margin-left: 5px; font-size: 11px; font-weight: bold; }
        .status-good { background-color: #34a853; color: white; }
        .status-bad { background-color: #ea4335; color: white; }
        .status-wait { background-color: #fbbc05; color: black; }

        /* --- Leaflet Map Container --- */
        #map, #chart-map {
            flex-grow: 1; /* Take remaining vertical space */
            background-color: #222; /* Fallback bg */
            width: 100%;
            z-index: 1; /* Below UI elements */
            cursor: grab; /* Default Leaflet cursor */
        }
        #map:active, #chart-map:active { cursor: grabbing; }

        /* Hide old canvas and location marker (now handled by Leaflet) */
        #canvas, #chart-canvas, #current-location { display: none !important; }

         /* Selected Cone Indicator (Optional: marker styling might be better) */
        .selected-cone-indicator {
            position: absolute;
            top: 55px; /* Adjust position */
            left: 10px;
            padding: 5px 10px;
            background-color: rgba(251, 188, 5, 0.8); /* Semi-transparent */
            color: black;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
            display: none;
            z-index: 600; /* Above map */
        }

        /* Controls Area */
        #controls {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
            z-index: 500; /* Above map */
            position: relative; /* Needed for z-index */
        }
        .control-row { display: flex; justify-content: space-between; gap: 10px; }

        /* Button Styles */
        button { padding: 10px; border: none; border-radius: 5px; font-weight: bold; font-size: 14px; cursor: pointer; text-align: center; flex-grow: 1; flex-basis: 0; white-space: nowrap; -webkit-tap-highlight-color: transparent; }
        button.primary { background-color: #4285f4; color: white; }
        button.active { background-color: #34a853; color: white; }
        button.danger { background-color: #ea4335; color: white; }
        button.warning { background-color: #fbbc05; color: black; }
        button:disabled { background-color: #777; color: #ccc; cursor: not-allowed; }

        /* Slider Styles */
        .slider-container { display: flex; flex-direction: column; padding: 8px 10px; background-color: rgba(40, 40, 40, 0.7); border-radius: 5px; gap: 5px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; }
        input[type="range"] { width: 100%; cursor: pointer; }

        /* Modal Styles */
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center; padding: 20px; }
        .modal-content { background-color: #282828; padding: 20px; border-radius: 10px; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 15px; }
        .modal-title { font-size: 18px; font-weight: bold; text-align: center; }
        .modal-input { width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #444; background-color: #333; color: white; font-size: 16px; }
        .modal-actions { display: flex; justify-content: space-between; gap: 10px; }

        /* Main Menu Styles */
        #main-menu-screen { justify-content: center; align-items: center; }
        #main-menu { display: flex; flex-direction: column; padding: 20px; width: 100%; max-width: 350px; align-items: center; gap: 20px; }
        .menu-title { font-size: 28px; margin-bottom: 20px; text-align: center; }
        .menu-button { width: 100%; padding: 15px; font-size: 18px; }

        /* Saved Charts Screen Styles */
        #charts-container { flex-grow: 1; overflow-y: auto; padding: 10px; }
        #no-charts-message { text-align: center; padding: 20px; color: #aaa; }
        #charts-list { list-style: none; border: 1px solid #444; border-radius: 5px; overflow: hidden; }
        .chart-item { padding: 12px 15px; border-bottom: 1px solid #444; cursor: pointer; font-size: 14px; display: flex; justify-content: space-between; align-items: center; }
        .chart-item:last-child { border-bottom: none; }
        .chart-item:hover { background-color: #333; }
        .chart-item-name { flex-grow: 1; margin-right: 10px; }
        .chart-item-details { font-size: 12px; color: #bbb; white-space: nowrap; }
        .chart-item button { flex-grow: 0; padding: 5px 8px; font-size: 12px; margin-left: 10px; }

        /* Chart View Screen Header */
        #chart-name { text-align: center; font-size: 16px; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; margin: 0 10px; }

        /* Back Button */
        .back-button {
            position: absolute;
            top: 8px; /* Align with header padding */
            left: 10px;
            padding: 8px 12px;
            background-color: rgba(50, 50, 50, 0.8); /* More opaque */
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            z-index: 600; /* Above map, below modal */
            font-size: 16px;
            line-height: 1;
            cursor: pointer;
        }

        /* --- Leaflet Marker Styling --- */
        .cone-marker-icon {
            font-size: 18px; /* Adjust emoji size */
            text-align: center;
            line-height: 1;
            /* Add border/background for visibility if needed */
            /* background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%; */
            border: 1px solid transparent; /* Placeholder for selection */
        }
        .cone-marker-icon.selected {
             /* Example selection style */
             border: 2px solid lime;
             border-radius: 50%;
             background-color: rgba(0, 255, 0, 0.2);
        }
        .leaflet-marker-draggable {
            cursor: grab;
        }
        .leaflet-marker-dragging {
            cursor: grabbing;
        }
        /* Adjust Leaflet attribution position if shown */
        .leaflet-control-attribution { font-size: 10px !important; background: rgba(255,255,255,0.7) !important; color: #333 !important; padding: 0 5px !important; }

    </style>
</head>
<body class="noselect">

    <!-- Main Menu Screen -->
    <div id="main-menu-screen" class="screen active">
        <div id="main-menu">
            <h1 class="menu-title">Autocross Mapper</h1>
            <button class="menu-button primary" id="new-chart-button">Create New Chart</button>
            <button class="menu-button" id="saved-charts-button">View Saved Charts</button>
            <button class="menu-button warning" id="import-chart-button-main">Import Chart</button>
        </div>
    </div>

    <!-- Mapping Screen -->
    <div id="mapping-screen" class="screen">
        <div id="app">
            <!-- Back Button moved inside #app for z-index stacking -->
            <button id="back-to-main-button" class="back-button">‚Üê</button>
            <!-- Optional Selected Cone Indicator -->
            <div id="selected-cone-indicator" class="selected-cone-indicator">Pointer Cone Selected</div>

            <div id="header">
                <div id="location-info">
                    Waiting for GPS...
                    <span id="accuracy-status" class="status-pill status-wait">WAIT</span>
                </div>
                <button id="save-button" class="primary" disabled>Save</button>
            </div>

            <!-- Leaflet Map Container -->
            <div id="map"></div>

            <div id="controls">
                <!-- GPS Accuracy Threshold Slider -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>GPS Accuracy Threshold:</span>
                        <span id="accuracy-threshold-value">10.0 m</span>
                    </div>
                    <input type="range" id="accuracy-threshold-slider" min="1" max="50" value="10" step="0.5">
                </div>

                <!-- Cone Type Selection -->
                <div class="control-row">
                    <button id="btn-pointer-cone" class="active">Pointer Cone</button>
                    <button id="btn-single-cone">Single Cone</button>
                </div>

                <!-- Tagging and Deleting -->
                <div class="control-row">
                    <button id="btn-tag-cone" class="primary" disabled>Tag Cone</button>
                    <button id="btn-delete-last-cone" class="danger">Delete Last</button>
                </div>

                <!-- REMOVED Zoom Controls -->
                <!-- REMOVED World Rotation Controls -->

                <!-- Pointer Cone Rotation Controls -->
                <div id="pointer-rotation-container" class="slider-container" style="display:none;">
                    <div class="slider-label">
                        <span>Selected Pointer Rotation:</span>
                        <span id="pointer-rotation-value">0¬∞</span>
                    </div>
                    <input type="range" id="pointer-rotation-slider" min="-180" max="180" value="0" step="1">
                </div>
            </div>
        </div>
    </div>

    <!-- Saved Charts Screen -->
    <div id="saved-charts-screen" class="screen">
         <div id="app">
            <button id="back-from-charts-button" class="back-button">‚Üê</button>

            <div id="header">
                <h2 style="text-align: center; flex-grow: 1;">Saved Charts</h2>
            </div>

            <div id="charts-container">
                <div id="no-charts-message">No saved charts yet. Create one or import a chart.</div>
                <ul id="charts-list"></ul>
            </div>

            <div id="controls">
                <div class="control-row">
                    <button id="import-chart-button-saved" class="primary">Import Chart</button>
                    <button id="delete-all-charts-button" class="danger">Delete All Charts</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart View Screen -->
    <div id="chart-view-screen" class="screen">
        <div id="app">
            <button id="back-from-chart-view-button" class="back-button">‚Üê</button>

            <div id="header">
                <h2 id="chart-name">Chart View</h2>
                <button id="export-current-chart-button" class="warning">Export</button>
            </div>

            <!-- Leaflet Chart Map Container -->
            <div id="chart-map"></div>

            <!-- REMOVED Chart Controls (Zoom/Rotate) -->
            <div id="controls" style="display:none;"> <!-- Hide controls section for now -->
            </div>
        </div>
    </div>

    <!-- Save Chart Modal -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Save Chart</div>
            <input type="text" id="chart-name-input" class="modal-input" placeholder="Enter chart name">
            <div class="modal-actions">
                <button id="cancel-save" class="danger">Cancel</button>
                <button id="confirm-save" class="primary">Save</button>
            </div>
        </div>
    </div>

    <!-- File Input (Hidden) -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <script>
        // ==== Enums and Constants ====
        const ConeType = {
            STARTING: 'starting',
            POINTER: 'pointer',
            SINGLE: 'single'
        };
        const INITIAL_MAP_ZOOM = 19; // Higher zoom for detail
        const INITIAL_CHART_ZOOM = 18;

        // ==== App State ====
        const state = {
            currentScreen: 'main-menu',
            selectedConeType: ConeType.POINTER,
            currentLocation: null, // { latitude, longitude, accuracy }
            cones: [],             // Array of Cone objects in the current mapping session
            selectedConeIndex: null,
            gpsAccuracyThreshold: 10.0,
            isGPSReady: false,
            savedCharts: [],
            currentViewingChart: null,
            pointerConeRotation: 0, // Default for NEW pointer cones

            // --- Leaflet Specific State ---
            mapInstance: null,          // Holds the main Leaflet map object
            chartMapInstance: null,     // Holds the chart view Leaflet map object
            userLocationMarker: null,   // Leaflet marker for user's position
            coneMarkersLayer: null,     // L.layerGroup for cones on main map
            chartMarkersLayer: null,    // L.layerGroup for cones on chart map
        };

        // ==== DOM Elements ====
        // Navigation & Screens
        const screens = {
            mainMenu: document.getElementById('main-menu-screen'),
            mapping: document.getElementById('mapping-screen'),
            savedCharts: document.getElementById('saved-charts-screen'),
            chartView: document.getElementById('chart-view-screen'),
        };
        const newChartButton = document.getElementById('new-chart-button');
        const savedChartsButton = document.getElementById('saved-charts-button');
        const backToMainButton = document.getElementById('back-to-main-button');
        const backFromChartsButton = document.getElementById('back-from-charts-button');
        const backFromChartViewButton = document.getElementById('back-from-chart-view-button');

        // Mapping Screen Elements
        const locationInfo = document.getElementById('location-info');
        const accuracyStatus = document.getElementById('accuracy-status');
        const saveButton = document.getElementById('save-button');
        const mapContainer = document.getElementById('map'); // Map div
        const selectedConeIndicator = document.getElementById('selected-cone-indicator');
        const accuracyThresholdSlider = document.getElementById('accuracy-threshold-slider');
        const accuracyThresholdValue = document.getElementById('accuracy-threshold-value');
        const btnPointerCone = document.getElementById('btn-pointer-cone');
        const btnSingleCone = document.getElementById('btn-single-cone');
        const btnTagCone = document.getElementById('btn-tag-cone');
        const btnDeleteLastCone = document.getElementById('btn-delete-last-cone');
        // REMOVED: zoomSlider, zoomValue, worldRotationSlider, rotationValue
        const pointerRotationContainer = document.getElementById('pointer-rotation-container');
        const pointerRotationSlider = document.getElementById('pointer-rotation-slider');
        const pointerRotationValue = document.getElementById('pointer-rotation-value');

        // Saved Charts Screen Elements
        const chartsContainer = document.getElementById('charts-container');
        const noChartsMessage = document.getElementById('no-charts-message');
        const chartsList = document.getElementById('charts-list');
        const importChartButtonMain = document.getElementById('import-chart-button-main');
        const importChartButtonSaved = document.getElementById('import-chart-button-saved');
        const deleteAllChartsButton = document.getElementById('delete-all-charts-button');

        // Chart View Screen Elements
        const chartMapContainer = document.getElementById('chart-map'); // Chart map div
        const chartName = document.getElementById('chart-name');
        const exportCurrentChartButton = document.getElementById('export-current-chart-button');
        // REMOVED: chartZoomSlider, chartZoomValue, chartRotationSlider, chartRotationValue

        // Modal Elements
        const modal = document.getElementById('modal');
        const chartNameInput = document.getElementById('chart-name-input');
        const cancelSaveButton = document.getElementById('cancel-save');
        const confirmSaveButton = document.getElementById('confirm-save');

        // Hidden File Input
        const importFileInput = document.getElementById('import-file-input');

        // ==== Core Classes ====
        class Cone {
            constructor(latitude, longitude, type = ConeType.SINGLE, rotation = 0) {
                this.latitude = latitude;
                this.longitude = longitude;
                this.type = type;
                this.rotation = rotation;
                this.id = 'cone_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.leafletMarker = null; // To store the associated Leaflet marker object
            }
        }

        // ==== Leaflet Icons ====
        // Use DivIcon with emoji or SVG for customization. Add 'cone-marker-icon' class.
        const singleConeIcon = L.divIcon({
            html: 'üü†',
            className: 'cone-marker-icon',
            iconSize: [20, 20], iconAnchor: [10, 10] // Center anchor
        });
        const pointerConeIcon = L.divIcon({
            html: 'üö©', // This emoji points right by default, rotation adjusts
            className: 'cone-marker-icon pointer-cone-icon',
            iconSize: [20, 20], iconAnchor: [10, 20] // Anchor at base/center
        });
        const startConeIcon = L.divIcon({
            html: 'üü¢',
            className: 'cone-marker-icon',
            iconSize: [20, 20], iconAnchor: [10, 10]
        });

        // ==== Utility Functions (Leaflet replaces most) ====
        // REMOVED: metersPerDegreeLongitude, screenToGeo, geoToScreen, calculateMetersPerPixel
        // REMOVED: updateConeScreenPositions, findConeAt

        // ==== Drawing Functions (Replaced by Leaflet Markers) ====
        // REMOVED: drawCones, drawMap, drawChartView, resizeCanvas (Leaflet handles resize)

        // ==== Leaflet Map Initialization ====
        function initializeMapView(centerCoords = [0, 0], zoom = INITIAL_MAP_ZOOM) {
            // Clean up existing map if necessary (e.g., switching from chart view)
            if (state.mapInstance) {
                 console.log("Removing existing map instance.");
                 state.mapInstance.remove();
                 state.mapInstance = null;
                 if (state.coneMarkersLayer) state.coneMarkersLayer.clearLayers(); // Clear layers too
                 if (state.userLocationMarker) state.userLocationMarker = null;
            }
            if (state.chartMapInstance) { // Also cleanup chart map if active
                 console.log("Removing existing chart map instance.");
                 state.chartMapInstance.remove();
                 state.chartMapInstance = null;
                 if(state.chartMarkersLayer) state.chartMarkersLayer.clearLayers();
            }


            if (!mapContainer) {
                console.error("Map container div not found!");
                return;
            }
            console.log("Initializing main map view at", centerCoords, "zoom", zoom);

            state.mapInstance = L.map(mapContainer, { // Use the div's ID
                center: centerCoords,
                zoom: zoom,
                zoomControl: true, // Show Leaflet's zoom control
                attributionControl: true // Show basic attribution
            });

            // Add Tile Layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 21, // Allow deep zoom
                maxNativeZoom: 19,
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap</a> contributors'
            }).addTo(state.mapInstance);

            // Initialize Layer Group for cone markers
            state.coneMarkersLayer = L.layerGroup().addTo(state.mapInstance);

            // Add map click listener to deselect cones
            state.mapInstance.on('click', deselectCone);

             // Add scale control
             L.control.scale({ imperial: false }).addTo(state.mapInstance);

            // Redraw existing cones if any (e.g., after screen switch back)
             if (state.cones.length > 0) {
                 console.log("Redrawing existing cones on map init");
                 state.cones.forEach((cone, index) => createOrUpdateConeMarker(cone, index)); // Recreate markers
             }
        }

        function initializeChartView(centerCoords, zoom = INITIAL_CHART_ZOOM, cones = []) {
             // Clean up existing map if necessary
            if (state.chartMapInstance) {
                 console.log("Removing existing chart map instance.");
                 state.chartMapInstance.remove();
                 state.chartMapInstance = null;
                 if(state.chartMarkersLayer) state.chartMarkersLayer.clearLayers();
            }
             if (state.mapInstance) { // Also cleanup main map if active
                 console.log("Removing existing main map instance.");
                 state.mapInstance.remove();
                 state.mapInstance = null;
                 if (state.coneMarkersLayer) state.coneMarkersLayer.clearLayers();
                 if (state.userLocationMarker) state.userLocationMarker = null;
            }

            if (!chartMapContainer) {
                console.error("Chart map container div not found!");
                return;
            }
             console.log("Initializing chart map view.");

            state.chartMapInstance = L.map(chartMapContainer).setView(centerCoords, zoom);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 21, maxNativeZoom: 19,
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap</a> contributors'
            }).addTo(state.chartMapInstance);

            state.chartMarkersLayer = L.layerGroup().addTo(state.chartMapInstance);

             // Add scale control
             L.control.scale({ imperial: false }).addTo(state.chartMapInstance);

            // Add markers for the loaded chart
            cones.forEach(coneData => {
                const cone = new Cone(coneData.latitude, coneData.longitude, coneData.type, coneData.rotation);
                // Use non-draggable markers for chart view
                createOrUpdateConeMarker(cone, -1, false, state.chartMarkersLayer);
            });

            // Fit map bounds to markers if there are any
            if (cones && cones.length > 0 && state.chartMapInstance) {
                try {
                    const bounds = L.latLngBounds(cones.map(c => [c.latitude, c.longitude]));
                     if (bounds.isValid()) {
                        state.chartMapInstance.fitBounds(bounds.pad(0.1)); // Add padding
                     } else {
                         console.warn("Could not create valid bounds for chart view.");
                         state.chartMapInstance.setView(centerCoords, zoom); // Fallback
                     }
                } catch(e) {
                     console.error("Error fitting bounds:", e);
                     state.chartMapInstance.setView(centerCoords, zoom); // Fallback
                 }
            } else if (state.chartMapInstance) {
                 state.chartMapInstance.setView(centerCoords, zoom); // Fallback if no cones
             }
        }


        // ==== Cone Management Functions (Leaflet Version) ====

        // Creates or updates a Leaflet marker for a cone
        function createOrUpdateConeMarker(cone, index, draggable = true, layerGroup = state.coneMarkersLayer) {
            if (!layerGroup) {
                 console.error("Target layer group is not available for cone marker.");
                 return;
             }

             // Remove existing marker if updating
             if (cone.leafletMarker) {
                 layerGroup.removeLayer(cone.leafletMarker);
                 cone.leafletMarker = null;
             }

            let icon;
            let markerOptions = {
                icon: singleConeIcon, // Default
                rotationOrigin: 'center center', // Adjust as needed for pointer cones
                rotationAngle: cone.rotation || 0,
                draggable: draggable // Make draggable for mapping screen
            };

            if (cone.type === ConeType.STARTING) icon = startConeIcon;
            else if (cone.type === ConeType.POINTER) icon = pointerConeIcon;
            else icon = singleConeIcon;

            markerOptions.icon = icon;

            // Use L.marker (or L.rotatedMarker for better rotation handling if needed)
            const marker = L.marker([cone.latitude, cone.longitude], markerOptions);

            // Store reference
            cone.leafletMarker = marker;

            // Add click listener ONLY if it's on the main mapping screen (index >= 0)
            if (index >= 0) {
                 marker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e); // Prevent map click from firing deselect
                    selectCone(index);
                });

                // Add drag listener ONLY if draggable
                if (draggable) {
                     marker.on('dragend', (e) => {
                        const draggedMarker = e.target;
                        const latLng = draggedMarker.getLatLng();
                        // Find the cone again by marker reference (index might change if cones deleted)
                        const coneIndex = state.cones.findIndex(c => c.leafletMarker === draggedMarker);
                        if (coneIndex !== -1) {
                            console.log(`Dragged cone ${coneIndex} to ${latLng.lat}, ${latLng.lng}`);
                            state.cones[coneIndex].latitude = latLng.lat;
                            state.cones[coneIndex].longitude = latLng.lng;
                            // Data updated, map already reflects visual change
                            updateSaveButtonState(); // Indicate change potentially
                        } else {
                            console.warn("Could not find cone associated with dragged marker");
                        }
                    });
                }
            }

            marker.addTo(layerGroup);

            // Apply selection style if this cone is currently selected
            if (index === state.selectedConeIndex && marker._icon) {
                 L.DomUtil.addClass(marker._icon, 'selected');
             }
        }

        function tagCone() {
            if (!state.currentLocation || !state.isGPSReady || !state.mapInstance) {
                 alert("GPS location not available, accuracy too low, or map not initialized.");
                 return;
            }

            let coneType = (state.cones.length < 2) ? ConeType.STARTING : state.selectedConeType;
            let coneRotation = (coneType === ConeType.POINTER) ? state.pointerConeRotation : 0;

            // Use the current GPS location
            const newCone = new Cone(
                state.currentLocation.latitude,
                state.currentLocation.longitude,
                coneType,
                coneRotation
            );

            // Add to state array FIRST to get the correct index
            state.cones.push(newCone);
            const newIndex = state.cones.length - 1;

            // Create the Leaflet marker for it
            createOrUpdateConeMarker(newCone, newIndex, true, state.coneMarkersLayer);

            console.log(`Tagged ${coneType} cone #${newIndex} at ${newCone.latitude}, ${newCone.longitude}`);

            updateSaveButtonState();

            if (newCone.type === ConeType.POINTER) {
                selectCone(newIndex); // Select the newly added pointer cone
            } else {
                 deselectCone(); // Deselect if it wasn't a pointer
             }
        }

        function deleteLastCone() {
            if (state.cones.length > 0) {
                const deletedConeIndex = state.cones.length - 1;
                const deletedCone = state.cones.pop();

                if (deletedCone.leafletMarker && state.coneMarkersLayer) {
                    state.coneMarkersLayer.removeLayer(deletedCone.leafletMarker);
                    console.log(`Removed marker for cone ${deletedConeIndex}`);
                }

                // If the deleted cone was selected, deselect
                if (state.selectedConeIndex === deletedConeIndex) {
                    deselectCone();
                }
                // No need to adjust selectedConeIndex otherwise, as it refers to the static array index

                updateSaveButtonState();
            }
        }

        function selectCone(index) {
             if (index === null || index < 0 || index >= state.cones.length) {
                 deselectCone();
                 return;
             }

             const coneToSelect = state.cones[index];
             if (!coneToSelect) return; // Safety check

            console.log("Selecting cone", index);

             // Deselect previous marker visually
             if (state.selectedConeIndex !== null && state.selectedConeIndex < state.cones.length) {
                 const prevCone = state.cones[state.selectedConeIndex];
                 if (prevCone && prevCone.leafletMarker && prevCone.leafletMarker._icon) {
                    L.DomUtil.removeClass(prevCone.leafletMarker._icon, 'selected');
                 }
             }

            state.selectedConeIndex = index;

            // Select new marker visually
            if (coneToSelect.leafletMarker && coneToSelect.leafletMarker._icon) {
                 L.DomUtil.addClass(coneToSelect.leafletMarker._icon, 'selected');
            }

            // Update UI for pointer cone rotation if applicable
            if (coneToSelect.type === ConeType.POINTER) {
                state.pointerConeRotation = coneToSelect.rotation; // Sync slider state
                pointerRotationSlider.value = coneToSelect.rotation;
                pointerRotationValue.textContent = `${Math.round(coneToSelect.rotation)}¬∞`;
                pointerRotationContainer.style.display = 'flex';
                // selectedConeIndicator.style.display = 'block'; // Optional UI indicator
            } else {
                pointerRotationContainer.style.display = 'none';
                // selectedConeIndicator.style.display = 'none';
            }
        }

        function deselectCone() {
             console.log("Deselecting cone");
            // Deselect previous marker visually
             if (state.selectedConeIndex !== null && state.selectedConeIndex < state.cones.length) {
                 const prevCone = state.cones[state.selectedConeIndex];
                 if (prevCone && prevCone.leafletMarker && prevCone.leafletMarker._icon) {
                    L.DomUtil.removeClass(prevCone.leafletMarker._icon, 'selected');
                 }
             }

            state.selectedConeIndex = null;
            pointerRotationContainer.style.display = 'none';
            // selectedConeIndicator.style.display = 'none';
        }

         function updateSelectedConeRotation(rotation) {
             if (state.selectedConeIndex !== null && state.cones[state.selectedConeIndex]) {
                 const cone = state.cones[state.selectedConeIndex];
                 if (cone.type === ConeType.POINTER) {
                    cone.rotation = rotation;
                    // Update the marker's rotation if it exists and has the method
                    if (cone.leafletMarker && typeof cone.leafletMarker.setRotationAngle === 'function') {
                        cone.leafletMarker.setRotationAngle(rotation);
                    } else if (cone.leafletMarker) {
                         // Basic marker rotation might require recreating icon or CSS workaround
                         console.warn("Marker doesn't support setRotationAngle. Using RotatedMarker plugin?");
                     }
                    updateSaveButtonState(); // Rotation is a change worth saving
                 }
            }
         }

         // REMOVED: moveSelectedCone (handled by Leaflet draggable marker + 'dragend' event)

         function updateSaveButtonState() {
             saveButton.disabled = state.cones.length === 0;
         }


        // ==== Geolocation Functions (Leaflet Integration) ====
        let watchId = null;
        let isFirstLocationUpdate = true; // Flag to force map centering on first fix

        function initGeolocation() {
            if ('geolocation' in navigator) {
                if (watchId !== null) {
                    navigator.geolocation.clearWatch(watchId);
                }
                updateLocationStatus("WAIT", "Requesting GPS...");
                if (state.userLocationMarker && state.mapInstance) { // Remove old marker if restarting
                    state.mapInstance.removeLayer(state.userLocationMarker);
                    state.userLocationMarker = null;
                }
                state.currentLocation = null;
                state.isGPSReady = false;
                btnTagCone.disabled = true;
                isFirstLocationUpdate = true; // Reset flag

                // Try to get a quick initial position
                navigator.geolocation.getCurrentPosition(
                    handleLocationUpdate,
                    handleLocationError,
                    { enableHighAccuracy: true, maximumAge: 60000, timeout: 10000 } // Allow cached pos initially
                );

                // Start watching for continuous updates
                watchId = navigator.geolocation.watchPosition(
                    handleLocationUpdate,
                    handleLocationError,
                    { enableHighAccuracy: true, maximumAge: 2000, timeout: 5000 } // High accuracy, recent data
                );
            } else {
                updateLocationStatus("BAD", "NO GPS", "Geolocation not supported");
                btnTagCone.disabled = true;
            }
        }

        function stopGeolocation() {
            if (watchId !== null && navigator.geolocation) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                updateLocationStatus("BAD", "OFF", "GPS Disabled");
                if (state.userLocationMarker && state.mapInstance) {
                    state.mapInstance.removeLayer(state.userLocationMarker);
                    state.userLocationMarker = null;
                }
                state.isGPSReady = false;
                btnTagCone.disabled = true;
            }
        }

        function handleLocationUpdate(position) {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const accuracy = position.coords.accuracy;

            state.currentLocation = { latitude: lat, longitude: lon, accuracy: accuracy };
            state.isGPSReady = accuracy <= state.gpsAccuracyThreshold;

            const latStr = lat.toFixed(6);
            const lonStr = lon.toFixed(6);
            const accStr = accuracy.toFixed(1);
            let statusText = `Lat:${latStr}, Lon:${lonStr} | Acc:${accStr}m`;

            if (state.isGPSReady) {
                 updateLocationStatus("GOOD", "OK", statusText);
                 btnTagCone.disabled = false;
            } else {
                updateLocationStatus("BAD", "ACC POOR", statusText);
                 btnTagCone.disabled = true;
            }

            // --- Update Leaflet Map ---
            if (state.mapInstance && state.currentScreen === 'mapping') {
                 const currentLatLng = L.latLng(lat, lon);

                 // Center map on first good fix or if accuracy is good
                 if (isFirstLocationUpdate && state.isGPSReady) {
                     console.log("First GPS fix, centering map.");
                     state.mapInstance.setView(currentLatLng, state.mapInstance.getZoom() || INITIAL_MAP_ZOOM);
                     isFirstLocationUpdate = false;
                 } else if (!isFirstLocationUpdate && state.isGPSReady) {
                    // Optionally keep centering or just pan
                    // state.mapInstance.panTo(currentLatLng);
                 }

                 // Update or create user location marker (Accuracy Circle)
                 if (!state.userLocationMarker) {
                     console.log("Creating user location marker.");
                     state.userLocationMarker = L.circle(currentLatLng, {
                         radius: accuracy,
                         color: 'blue', fillColor: '#30f', fillOpacity: 0.15, weight: 1
                     }).addTo(state.mapInstance);
                     // Add a center dot too
                     L.circleMarker(currentLatLng, { radius: 4, color: 'white', fillColor: 'blue', fillOpacity: 1, weight: 1}).addTo(state.userLocationMarker); // Add to circle layer
                 } else {
                     state.userLocationMarker.setLatLng(currentLatLng);
                     state.userLocationMarker.setRadius(accuracy);
                     // Update center dot position if added separately
                     if (state.userLocationMarker.getLayers && state.userLocationMarker.getLayers().length > 0) {
                        state.userLocationMarker.getLayers()[0].setLatLng(currentLatLng);
                     }
                 }
            } else if (!state.mapInstance && state.currentScreen === 'mapping') {
                 // If map wasn't initialized yet (e.g., GPS faster than screen switch), initialize it now
                 initializeMapView([lat, lon]);
            }
        }

        function handleLocationError(error) {
            console.error('Geolocation Error:', error.code, error.message);
             let message = 'GPS Error';
             let label = "ERROR";
             switch(error.code) {
                case error.PERMISSION_DENIED: message = "GPS Permission Denied"; label="DENIED"; break;
                case error.POSITION_UNAVAILABLE: message = "GPS Position Unavailable"; label="UNAVAIL"; break;
                case error.TIMEOUT: message = "GPS Timeout"; label="TIMEOUT"; break;
            }
             updateLocationStatus("BAD", label, message);
             state.currentLocation = null;
             state.isGPSReady = false;
             btnTagCone.disabled = true;
             if (state.userLocationMarker && state.mapInstance) {
                 state.mapInstance.removeLayer(state.userLocationMarker);
                 state.userLocationMarker = null;
             }
        }

        function updateLocationStatus(statusType, statusLabel, infoText = "Waiting for GPS...") {
             const statusPillHTML = `<span id="accuracy-status" class="status-pill status-${statusType.toLowerCase()}">${statusLabel}</span>`;
             locationInfo.innerHTML = `${infoText} ${statusPillHTML}`;
        }

        // ==== Storage Functions ====
        const STORAGE_KEY = 'autocrossCharts_v2'; // Use new key if format changed significantly

        function saveCurrentChart(name) {
            if (state.cones.length === 0) {
                alert('No cones to save!');
                return false;
            }

             // Extract only necessary data, exclude leafletMarker
            const serializableCones = state.cones.map(c => ({
                 latitude: c.latitude, longitude: c.longitude,
                 type: c.type, rotation: c.rotation, id: c.id
             }));

            const chartData = {
                name: name,
                coneData: serializableCones,
                // worldRotation: state.worldRotation, // No longer relevant with Leaflet maps
                createdAt: new Date().toISOString()
            };

            loadSavedCharts();
            const existingIndex = state.savedCharts.findIndex(c => c.name === name);
            if (existingIndex !== -1) {
                 state.savedCharts.splice(existingIndex, 1);
             }
            state.savedCharts.push(chartData);

            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));
                alert(`Chart "${name}" saved successfully!`);
                return true;
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                alert("Error saving chart. Storage might be full.");
                loadSavedCharts(); // Revert state if save failed
                 return false;
            }
        }

        function loadSavedCharts() {
            try {
                const storedCharts = localStorage.getItem(STORAGE_KEY);
                state.savedCharts = storedCharts ? JSON.parse(storedCharts) : [];
                if (!Array.isArray(state.savedCharts)) { // Basic validation
                     console.warn("Stored chart data is not an array. Resetting.");
                     state.savedCharts = [];
                     localStorage.removeItem(STORAGE_KEY);
                }
            } catch (e) {
                console.error("Error loading charts from localStorage:", e);
                state.savedCharts = [];
            }
             return state.savedCharts;
        }

        // deleteChart, deleteAllCharts, exportChart, importChartFromFile, triggerImport remain largely the same
        // as they operate on the saved data structure (which hasn't changed much)
        function deleteChart(chartNameToDelete) {
            if (!confirm(`Are you sure you want to delete the chart "${chartNameToDelete}"? This cannot be undone.`)) {
                 return;
            }
             loadSavedCharts();
             state.savedCharts = state.savedCharts.filter(chart => chart.name !== chartNameToDelete);
             try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));
                updateChartsList();
            } catch (e) {
                 console.error("Error saving updated charts list:", e);
                 alert("Error deleting chart from storage.");
                 loadSavedCharts();
            }
         }

         function deleteAllCharts() {
             if (state.savedCharts.length === 0) {
                 alert("There are no charts to delete.");
                 return;
             }
             if (!confirm("Are you sure you want to delete ALL saved charts? This cannot be undone.")) {
                 return;
             }
             state.savedCharts = [];
             try {
                 localStorage.removeItem(STORAGE_KEY);
                 updateChartsList();
             } catch (e) {
                 console.error("Error deleting all charts:", e);
                 alert("Error clearing chart storage.");
                 loadSavedCharts();
             }
         }

        function exportChart(chart) {
             if (!chart) {
                 alert("No chart selected for export.");
                 return;
             }
            try {
                 // Ensure we only export the core data
                 const exportData = {
                     name: chart.name,
                     coneData: chart.coneData.map(c => ({
                         latitude: c.latitude, longitude: c.longitude,
                         type: c.type, rotation: c.rotation, id: c.id // Keep ID if needed for imports?
                     })),
                     // worldRotation: chart.worldRotation || 0, // No longer needed
                     createdAt: chart.createdAt
                 };

                const chartJson = JSON.stringify(exportData, null, 2);
                const blob = new Blob([chartJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                 const filename = chart.name.replace(/[^a-z0-9_ -]/gi, '_').replace(/\s+/g, '_');
                 a.download = `${filename || 'autocross_chart'}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                setTimeout(() => URL.revokeObjectURL(url), 100);
             } catch (error) {
                 console.error("Error exporting chart:", error);
                 alert("Could not export chart data.");
             }
        }

        function importChartFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Validation... (ensure name, coneData array, lat/lon/type exist)
                     if (typeof importedData !== 'object' || importedData === null) throw new Error("Invalid file format.");
                     if (typeof importedData.name !== 'string' || !importedData.name.trim()) throw new Error("Chart name missing.");
                     if (!Array.isArray(importedData.coneData)) throw new Error("Invalid cone data.");

                     // Basic validation of cone structure
                     for(const cone of importedData.coneData) {
                         if (typeof cone.latitude !== 'number' || typeof cone.longitude !== 'number' || typeof cone.type !== 'string') {
                             throw new Error("Invalid data structure within coneData.");
                         }
                         cone.rotation = typeof cone.rotation === 'number' ? cone.rotation : 0; // Default rotation
                     }


                     loadSavedCharts();
                     const existingChart = state.savedCharts.find(c => c.name === importedData.name);
                     if (existingChart) {
                         if (!confirm(`A chart named "${importedData.name}" already exists. Overwrite it?`)) {
                             alert("Import cancelled.");
                             importFileInput.value = ''; return;
                         }
                          state.savedCharts = state.savedCharts.filter(c => c.name !== importedData.name);
                     }

                     const newChart = { // Reconstruct to ensure format
                         name: importedData.name,
                         coneData: importedData.coneData, // Already validated somewhat
                         createdAt: importedData.createdAt || new Date().toISOString()
                     };

                    state.savedCharts.push(newChart);
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.savedCharts));
                    alert(`Chart "${newChart.name}" imported successfully!`);
                    if(state.currentScreen === 'savedCharts') updateChartsList();

                } catch (error) {
                    console.error("Error importing chart:", error);
                    alert('Error importing chart: ' + error.message);
                } finally {
                     importFileInput.value = '';
                 }
            };
             reader.onerror = function() { alert('Error reading the selected file.'); importFileInput.value = ''; };
            reader.readAsText(file);
        }

        function triggerImport() { importFileInput.click(); }

        // updateChartsList remains the same, just displays data from state.savedCharts
        function updateChartsList() {
            loadSavedCharts(); // Ensure list is current

            if (state.savedCharts.length === 0) {
                noChartsMessage.style.display = 'block';
                chartsList.style.display = 'none';
                chartsList.innerHTML = '';
            } else {
                noChartsMessage.style.display = 'none';
                chartsList.style.display = 'block';
                chartsList.innerHTML = ''; // Clear existing list

                const sortedCharts = [...state.savedCharts].sort((a, b) =>
                    (b.createdAt || 0).localeCompare(a.createdAt || 0) // Sort descending by date string
                );

                sortedCharts.forEach(chart => {
                    const li = document.createElement('li');
                    li.className = 'chart-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'chart-item-name';
                    nameSpan.textContent = chart.name;

                    const detailsSpan = document.createElement('span');
                    detailsSpan.className = 'chart-item-details';
                    let dateStr = 'Unknown date';
                    if (chart.createdAt) {
                         try { dateStr = new Date(chart.createdAt).toLocaleDateString(); } catch (e) {}
                     }
                    const coneCount = Array.isArray(chart.coneData) ? chart.coneData.length : 0;
                    detailsSpan.textContent = `${coneCount} cones (${dateStr})`;

                     const deleteBtn = document.createElement('button');
                     deleteBtn.className = 'danger';
                     deleteBtn.textContent = 'Del';
                     deleteBtn.onclick = (e) => { e.stopPropagation(); deleteChart(chart.name); };

                    li.appendChild(nameSpan);
                    li.appendChild(detailsSpan);
                    li.appendChild(deleteBtn);

                    li.addEventListener('click', () => { viewChart(chart); });
                    chartsList.appendChild(li);
                });
            }
        }


        function viewChart(chart) {
            if (!chart || !Array.isArray(chart.coneData)) {
                alert("Invalid chart data.");
                return;
            }
            state.currentViewingChart = chart;
            chartName.textContent = chart.name;

            // Determine center point (e.g., first cone or average)
             let centerCoords = [0, 0]; // Default fallback
             if (chart.coneData.length > 0) {
                 centerCoords = [chart.coneData[0].latitude, chart.coneData[0].longitude];
             }

            // Navigate will handle map initialization
            navigateToScreen('chartView');
        }

        function generateChartName() {
            const now = new Date();
            const date = now.toISOString().split('T')[0];
            const time = now.toTimeString().split(' ')[0].replace(/:/g, '-');
            return `Chart_${date}_${time}`;
        }

        // ==== Navigation ====
        function navigateToScreen(screenId) {
            console.log("Navigating to:", screenId);
            Object.values(screens).forEach(screen => screen.classList.remove('active'));

             if (screens[screenId]) {
                 screens[screenId].classList.add('active');
                 const oldScreen = state.currentScreen;
                 state.currentScreen = screenId;

                // --- Screen Specific Setup ---
                switch(screenId) {
                    case 'mapping':
                        stopGeolocation(); // Stop first if running from previous state
                        // Reset mapping state (cones, selection)
                        state.cones = [];
                        state.selectedConeIndex = null;
                        deselectCone(); // Update UI related to selection
                        if(state.coneMarkersLayer) state.coneMarkersLayer.clearLayers(); // Clear map layers

                        // Use last known good GPS coords if available, else 0,0
                        const startCoords = state.currentLocation ? [state.currentLocation.latitude, state.currentLocation.longitude] : [0, 0];
                        initializeMapView(startCoords); // Init/Re-init map
                        updateSaveButtonState();
                        initGeolocation(); // Start GPS for this screen
                        break;

                    case 'savedCharts':
                        stopGeolocation(); // Stop GPS if coming from mapping
                        // Clean up map instances if they exist
                         if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; }
                         if (state.chartMapInstance) { state.chartMapInstance.remove(); state.chartMapInstance = null; }
                        updateChartsList();
                        break;

                    case 'chartView':
                         stopGeolocation(); // Stop GPS if coming from mapping
                         if (!state.currentViewingChart) {
                             console.error("Cannot navigate to chart view without a chart selected.");
                             navigateToScreen('savedCharts'); // Go back
                             return;
                         }
                         let centerCoords = [0, 0];
                         if (state.currentViewingChart.coneData.length > 0) {
                             centerCoords = [state.currentViewingChart.coneData[0].latitude, state.currentViewingChart.coneData[0].longitude];
                         }
                         // Initialize chart map view
                         initializeChartView(centerCoords, INITIAL_CHART_ZOOM, state.currentViewingChart.coneData);
                         break;

                    case 'mainMenu':
                         stopGeolocation();
                         state.currentViewingChart = null;
                         state.cones = []; // Clear mapping cones when going home
                         // Clean up map instances
                         if (state.mapInstance) { state.mapInstance.remove(); state.mapInstance = null; }
                         if (state.chartMapInstance) { state.chartMapInstance.remove(); state.chartMapInstance = null; }
                         break;
                 }

                 // Invalidate size after screen transition IF map exists for the new screen
                 // Use timeout to ensure layout is complete
                 setTimeout(() => {
                     if (screenId === 'mapping' && state.mapInstance) {
                         console.log("Invalidating map size");
                         state.mapInstance.invalidateSize();
                     } else if (screenId === 'chartView' && state.chartMapInstance) {
                         console.log("Invalidating chart map size");
                         state.chartMapInstance.invalidateSize();
                         // Re-fit bounds after invalidate might be needed
                         if (state.currentViewingChart && state.currentViewingChart.coneData.length > 0) {
                             const bounds = L.latLngBounds(state.currentViewingChart.coneData.map(c => [c.latitude, c.longitude]));
                              if (bounds.isValid()) state.chartMapInstance.fitBounds(bounds.pad(0.1));
                          }
                     }
                 }, 100); // Small delay

            } else {
                 console.error("Screen ID not found:", screenId);
             }
        }

        // ==== Event Handlers ====

        // REMOVED: Canvas Interaction Handlers (handlePointerDown, etc.)

        // -- Button Clicks --
        newChartButton.addEventListener('click', () => navigateToScreen('mapping'));
        savedChartsButton.addEventListener('click', () => navigateToScreen('savedCharts'));
        backToMainButton.addEventListener('click', () => navigateToScreen('mainMenu'));
        backFromChartsButton.addEventListener('click', () => navigateToScreen('mainMenu'));
        backFromChartViewButton.addEventListener('click', () => navigateToScreen('savedCharts')); // Go back to list

        btnPointerCone.addEventListener('click', () => {
            state.selectedConeType = ConeType.POINTER;
            btnPointerCone.classList.add('active');
            btnSingleCone.classList.remove('active');
        });
        btnSingleCone.addEventListener('click', () => {
            state.selectedConeType = ConeType.SINGLE;
            btnSingleCone.classList.add('active');
            btnPointerCone.classList.remove('active');
        });

        btnTagCone.addEventListener('click', tagCone);
        btnDeleteLastCone.addEventListener('click', deleteLastCone);
        saveButton.addEventListener('click', () => {
             if (state.cones.length > 0) {
                 chartNameInput.value = generateChartName();
                 modal.style.display = 'flex';
             }
         });

         deleteAllChartsButton.addEventListener('click', deleteAllCharts);
         importChartButtonMain.addEventListener('click', triggerImport);
         importChartButtonSaved.addEventListener('click', triggerImport);
         importFileInput.addEventListener('change', (event) => {
             if (event.target.files.length > 0) {
                 importChartFromFile(event.target.files[0]);
             }
         });
         exportCurrentChartButton.addEventListener('click', () => {
             exportChart(state.currentViewingChart);
         });

        // -- Slider Inputs --
        accuracyThresholdSlider.addEventListener('input', () => {
            state.gpsAccuracyThreshold = parseFloat(accuracyThresholdSlider.value);
            accuracyThresholdValue.textContent = `${state.gpsAccuracyThreshold.toFixed(1)} m`;
            // Re-evaluate GPS status if location is known
            if (state.currentLocation) {
                handleLocationUpdate({ coords: state.currentLocation }); // Fake update to re-check status
            }
        });

        // REMOVED: zoomSlider, worldRotationSlider listeners

        pointerRotationSlider.addEventListener('input', () => {
             const rotation = parseFloat(pointerRotationSlider.value);
             state.pointerConeRotation = rotation; // Update default for next cone
             pointerRotationValue.textContent = `${Math.round(rotation)}¬∞`;
             updateSelectedConeRotation(rotation); // Update the currently selected cone's marker
         });

        // REMOVED: chartZoomSlider, chartRotationSlider listeners

        // -- Modal Actions --
        confirmSaveButton.addEventListener('click', () => {
            const name = chartNameInput.value.trim();
            if (!name) {
                alert('Please enter a valid chart name.'); return;
            }
             loadSavedCharts(); // Check against latest list
             const existing = state.savedCharts.find(c => c.name === name);
             if (existing) {
                 if (!confirm(`A chart named "${name}" already exists. Overwrite it?`)) return;
             }
            if (saveCurrentChart(name)) {
                 modal.style.display = 'none';
                 // Maybe navigate back to main menu or saved charts after save?
                 // navigateToScreen('savedCharts');
             }
        });
        cancelSaveButton.addEventListener('click', () => { modal.style.display = 'none'; });


        // ==== Initialization ====
        function initApp() {
             console.log("Autocross Mapper Initializing (Leaflet Version)...");
             // REMOVED: Canvas listeners

             // Initial setup
             loadSavedCharts();
             navigateToScreen('mainMenu'); // Start at main menu

             // Leaflet handles map resize automatically usually, but listen for window resize for potential layout shifts
             window.addEventListener('resize', () => {
                  // Invalidate map size slightly after resize event settles
                  setTimeout(() => {
                      if (state.currentScreen === 'mapping' && state.mapInstance) {
                          state.mapInstance.invalidateSize();
                      } else if (state.currentScreen === 'chartView' && state.chartMapInstance) {
                          state.chartMapInstance.invalidateSize();
                      }
                  }, 250);
              });


            console.log("Autocross Mapper Initialized.");
        }

        // Start the app
        window.addEventListener('load', initApp);

    </script>
</body>
</html>